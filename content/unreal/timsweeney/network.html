
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3c.org/TR/1999/REC-html401-19991224/loose.dtd"> 

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">



<head>
	<title>Tim Sweeney's Network</title>
	<meta http-equiv="content-type"	content="text/html;	charset=utf-8"	/>
	<meta name="robots" content="index,follow" />
	<meta name="language" content="en" />

	<link rel="stylesheet" type="text/css" href="styles/styles.css" />
</head>

<body>
  
<b>Unreal Networking Architecture</b>

<address>Tim Sweeney
<br>
Epic MegaGames, Inc.
<br>
http://www.epicgames.com/ </address>

<p>Audience: Advanced UnrealScript Programmers, C++ Programmers.
<br>
Last Updated: 07/21/99</p>

<p>Note: References to Unreal's C++ code are only relevant to Unreal licensees 
who have access to the Unreal source.</p>

<b>History</b>

<p>Multiplayer gaming is about shared reality: that all of the players feel they 
are in the same world, seeing from differing viewpoints the same events 
transpiring within that world.&nbsp; As multiplayer gaming has evolved from the 
little 2-player modem games that characterized Doom, into the large, persistent, 
more free-form interactions of games like Quake 2, Unreal, and Ultima Online, 
the technologies behind the shared reality have evolved tremendously.</p>

<p>In the beginning, there were peer-to-peer games like Doom and Duke Nukem. In 
these games, each machine in the game was an equal.&nbsp; Each exactly 
synchronized its input and timing with the others, and each machine carried out 
the same exact game logic on exactly the same inputs. In conjunction with 
completely deterministic (i.e. fixed-rate, non-random) game logic, all players 
in the machine perceived the same reality.&nbsp; The advantage of this approach 
was simplicity.&nbsp; The disadvantages were: 
<UL>
  <LI>Lack of persistence. All of the players had to start the game together, 
  and new players couldn't come and go as they pleased. 
  <LI>Lack of player scalability: Because of the lock-step nature of the 
  networking architecture, the coordination overhead and chance of 
  network-induced failure increases linearly with the number of players. 
  <LI>Lack of frame rate scalability. All of the players had to run at the same 
  internal frame rate, making it difficult to support a wide variety of machine 
  speeds. </LI></UL>

<p>Next came the monolithic client-server architecture, pioneered by Quake, and 
later used by Ultima Online.&nbsp; Here, one machine was designated "server", 
and was responsible for making all of the gameplay decisions.&nbsp; The other 
machines were "clients", and they were regarded as dumb rendering terminals, 
which sent their keystrokes to the server, and received a list of objects to 
render.&nbsp; This advancement enabled large-scale Internet gaming, as game 
servers started springing up all over the Internet.&nbsp; The client-server 
architecture was later extended by QuakeWorld and Quake 2, which moved 
additional <EM>simulation</EM> and <EM>prediction</EM> logic to the client side, 
in order to increase visible detail while lowering bandwidth usage. Here, the 
client receives not only a list of objects to render, but also information about 
their trajectories, so the client can make rudimentary predictions about object 
motion. In addition, a lock-step prediction protocol was introduced in order to 
eliminate perceived latency in client movement.&nbsp; Still, there were some 
disadvantages to this approach: 
<UL>
  <LI>Lack of open-endedness: When users and licensees create new types of 
  objects (weapons, player controls, etc), glue logic must be authored to 
  specify the simulation and prediction aspects of those new objects. 
  <LI>Difficulties of the prediction model: In this model, the network code and 
  the game code are separate modules, yet each must both be fully aware of the 
  implementation of the other, in order to keep the game state reasonably 
  synchronized. A strong coupling between (ideally) separate modules is 
  undesirable because it makes extensibility difficult. </LI></UL>

<p>Unreal introduces into multiplayer gaming a new approach termed the 
generalized client-server model.&nbsp; In this model, the server is still 
authoritative over the evolution of the game state.&nbsp; However, the client 
actually maintains an accurate subset of the game state locally, and can predict 
the game flow by executing the same game code as the server, on approximately 
the same data, thus minimizing the amount of data that must be exchanged between 
the two machines.&nbsp; Further, the "game state" is self-described by an 
extensible, object-oriented scripting language which fully decouples the game 
logic from the network code.&nbsp; The network code is generalized in such a way 
that it can coordinate <EM>any</EM> game which can be described by the 
language.&nbsp; This achieves a goal of object-orientation which increases 
extensibility, the concept that the behavior of an object should be fully 
described by that object, without introducing dependencies on other pieces of 
code which are hard-wired to know about the internal implementation of that 
object.</p>

<b>Basic Concepts</b>

<b>Goal</b>

<p>The goal here is to define Unreal's networking architecture in a fairly 
rigorous manner, because there is a fair amount of complexity involved that is 
easy to misinterpret if not defined exactly.</p>

<b>Basic Terminology</b>

<p>We define our basic terminology precisely: 

<UL>
  <LI>A <b>variable</b> is an association between a fixed name and a 
  modifiable value.&nbsp; Examples of variables include integers such as X=123, 
  floating point numbers such as Y=3.14, strings such as Team="Rangers", and 
  vectors such as V=(1.5,2.5,-0.5). 
  <LI>An <b>object</b> is a self-contained data structure consisting 
  of a fixed set of <b>variables</b>. 
  <LI>An <b>actor</b> is an object capable of independently moving 
  around in a <b>level</b> and interacting with other actors in that 
  <b>level</b>. 
  <LI>A <b>level</b> is an object which contains a set of 
  <b>actors</b>. 
  <LI>A <b>tick</b> is an operation that updates the entire 
  <b>game state</b> given that a variable amount of time called 
  DeltaTime has passed. 
  <LI>The <b>game state</b> of a <b>level</b> refers to the 
  complete set of all <b>actors</b> that exist in that 
  <b>level</b> and the current values of all of their 
  <b>variables</b> at a time when a <b>tick</b> operation is 
  not currently in progress. 
  <LI>A client is a running instance of <b>Unreal.exe</b> which 
  maintains an approximate subset of the <b>game state</b> suitable 
  for approximately simulating the events that occur in the world, and for 
  rendering an approximate view of the world for a player. 
  <LI>A <b>server</b> is a running instance of Unreal.exe which is 
  responsible for <b>ticking</b> a single <b>level</b> and 
  communicating the <b>game state</b> authoritatively to all of the 
  <b>clients</b>. </LI></UL>

<b>The Update Loop</b>

<p>All of the above concepts are well-understood with the possible exception of 
the <b>tick</b> and <b>game state</b>.&nbsp; So, these will 
be described in more detail. First of all, here is a simple description of 
Unreal's update loop: 
<OL>
  <LI>If I am a <b>server</b>, communicate the current <b>game 
  state</b> to all of my <b>clients</b>. 
  <LI>If I am a <b>client</b>, send my requested movement to the 
  server, receive new <b>game state</b> information from the server, 
  render my current approximate view of the world to the screen. 
  <LI>Perform a <b>tick</b> operation to update the <b>game 
  state</b>, given that a variable amount of time DeltaTime has passed 
  since the previous <b>tick</b>. </LI></OL>

<p>A <b>tick</b> operation involves updating all of the 
<b>actors</b> in the level, carrying out their physics, informing them 
of interesting game events that have occurred, and executing any necessary 
script code.&nbsp; Unlike many past games such as Doom and Quake, all of the 
physics and update code in Unreal is designed to handle a variable amount of 
time passing.&nbsp; For example, Doom's movement physics looks like "Position += 
PositionIncrment" while Unreal's looks like "Position += Velocity * DeltaTime". 
This enables greater frame rate scalability.</p>

<p>While a <b>tick</b> operation is in progress, the <b>game 
state</b> is being continually modified by the code which executes.&nbsp; 
The <b>game state</b> can change in exactly three ways: 
<UL>
  <LI>A <b>variable</b> in an <b>actor</b> can be modified. 
  <LI>An <b>actor</b> can be created. 
  <LI>An <b>actor</b> can be destroyed. </LI></UL>

<b>The Server Is <EM>The Man</EM></b>

<p>From the above, the server's <b>game state</b> is completely and 
concisely defined by the set of all <b>variables</b> of all 
<b>actors</b> within a <b>level</b>.&nbsp; Because the 
<b>server</b> is authoritative about the gameplay flow, the server's 
<b>game state</b> can always be regarded as the one true <b>game 
state</b>.&nbsp; The version of the <b>game state</b> on 
<b>client</b> machines should always be regarded as an approximation 
subject to many different kinds of deviations from the server's <b>game 
state</b>. &nbsp; Actors that exist on the <b>client</b> machine 
should be considered <b>proxies</b> because they are a temporary, 
approximate representation of an object rather than the object itself.</p>

<b>Bandwidth Limitation</b>

<p>If network bandwidth were unlimited, the network code would be very simple: 
at the end of each <b>tick</b>, the server could just send each 
<b>client</b> the complete and exact <b>game state</b> so 
that the client always renders the exact view of the game as is occurring on the 
server.&nbsp; However, the Internet reality is that 28.8K modems have only 
perhaps 1% of the bandwidth necessary to communicate complete and exact 
updates.&nbsp; While consumers' Internet connections will become faster in the 
future, bandwidth is growing at a rate far lower than Moore's law which defines 
the rate of improvement in games and graphics. Therefore, there is <EM>not now 
and never will be</EM> sufficient bandwidth for complete game-state updates.</p>

<p>So, the main goal of the network code is to enable the 
<b>server</b> to communicate a <EM>reasonable approximation</EM> of 
the <b>game state</b> to the <b>clients</b> so that the 
<b>clients</b> can render an interactive view of the world which is as 
close to shared reality as is reasonable given bandwidth limitations.</p>

<b>Replication</b>

<p>Unreal views the general problem of "coordinating a reasonable approximation 
of a shared reality between the server and clients" as a problem of 
"replication".&nbsp; That is, a problem of determining a set of data and 
commands that flow between the client and server in order to achieve that 
approximate shared reality.</p>

<b>The Relevant Set of Actors</b>

<b>Definition</b>

<p>An Unreal level can be huge, and at any time a player can only see a small 
fraction of the actors in that level.&nbsp; Most of the other actors in the 
level aren't visible, aren't audible, and have no significant effect on the 
player.&nbsp; The set of actors that a <b>server</b> deems are visible 
to or capable of affecting a <b>client</b> are deemed the 
<b>relevant set </b>of actors&nbsp; for that client.&nbsp; A 
significant bandwidth optimization in Unreal's network code is that the server 
only tells clients about actors in that client's <b>relevant 
set</b>.</p>

<p>Unreal applies the following rules in determining the relevant set of actors 
for a player. 
<OL>
  <LI>The actor belongs to the ZoneInfo class, then it is relevant. 
  <LI>If the actor has static=true or bNoDelete=true, then it is relevant. 
  <LI>If the actor is owned by the player (Owner==Player), then it is relevant. 
  <LI>If the actor is a Weapon and is owned by a visible actor, then it is 
  relevant. 
  <LI>If the actor is hidden (bHidden=true) and it doesn't collide 
  (bBlockPlayers=false) and it doesn't have an ambient sound 
  (AmbientSound==None) then the actor is not relevant. 
  <LI>If the actor is visible according to a line-of-sight check between the 
  actor's Location and the player's Location, then it is relevant. 
  <LI>If the actor was visible less than 2 to 10 seconds ago (the exact number 
  varies because of some performance optimizations), then it is relevant. 
</LI></OL>

<p>These rules are designed to give a good approximation of the set of actors 
which really can affect a player.&nbsp; Of course, it is imperfect: the 
line-of-sight check can sometimes give a false negative with large actors 
(though we use some heuristics to help it out), it doesn't account for sound 
occlusion of ambient sounds, and so on. However, the approximation is such that 
its error is overwhelmed by the error inherent in a network environment with 
such latency and packet loss characteristics as the Internet.</p>

<b>Changing the definition of the relevant set in C++</b>

<p>The set of relevant actors for a client is determined by the C++ function 
ULevel::GetRelevantActors.&nbsp; This way, licensees who want to implement 
different gameplay rules are free to modify our definition of the 
<b>relevant set</b> by modifying ULevel::GetRelevantActors or (better 
yet) subclassing ULevel, and overriding the function.</p>

<b>Actor Prioritization</b>

<p>In deathmatch games on modem-based Internet connections, there is almost 
never enough bandwidth available for the server to tell each client everything 
it desires to know about the game state, Unreal uses a load-balancing technique 
that prioritizes all actors, and gives each one a "fair share" of the bandwidth 
based on "how important" it is to gameplay.</p>

<p>Each actor has a floating point variable called NetPriority.&nbsp; The higher 
the number, the more bandwidth that actor receives relative to others.&nbsp; An 
actor with a priority of 2.0 will be updated exactly twice as frequently as an 
actor with priority 1.0. &nbsp; The only thing that matters with priorities is 
their ratio; so obviously you can't improve Unreal's network performance by 
increasing all of the priorities.&nbsp; Some of the values of NetPriority we 
have assigned in our performance-tuning are: 
<UL>
  <LI>Bots: 8.0 
  <LI>Movers: 7.0 
  <LI>Projectiles: 6.0 
  <LI>Pawns: 4.0 
  <LI>Decorative creatures (such as fish): 2.0 
  <LI>Decorations: 0.5 </LI></UL>

<b>Overview of Replication</b>

<b>Three Types of Replication</b>

<p>The network code is based on three primitive, low-level replication 
operations for communicating information about the <b>game state</b> 
between the the <b>server</b> and <b>clients</b>: 
<UL>
  <LI><b>Actor replication</b>.&nbsp; The server identifies the set of 
  "<b>relevant</b>" actors for each client (actors which are either 
  visible to the client or are likely to somehow affect the client's view or 
  movement instantaneously), and tells the client to create and maintain a 
  "replicated" copy of that actor.&nbsp; While the server always has the 
  authoritative version of that actor, at any time many clients might have 
  approximate, replicated versions of that actor. </LI></UL>
<UL>
  <LI><b>Variable replication</b>. Actor variables that describe 
  aspects of the game state which are important to clients can be 
  "replicated".&nbsp; That is, whenever the value of the variable changes on the 
  server side, the server sends the client the updated value. </LI></UL>
<UL>
  <LI><b>Function call replication</b>. A function that is called on 
  the server in a network game can be routed to the remote client rather than 
  executed locally. Alternatively, a function called on the client side may be 
  routed to the server, rather than called locally. </LI></UL>

<p>To give a concrete example, consider the case where you are a client in a 
network game. &nbsp; You see two opponents running toward you, shooting at you, 
and you hear their shots.&nbsp; Since all of the <b>game state</b> is 
being maintained on the server rather than on your machine, why can you see and 
hear those things happening? 
<UL>
  <LI>You can see the opponents because the server has recognized that the 
  opponents are "<b>relevant</b>" to you (i.e. they are visible) and 
  the server is currently <b>replicating</b> those 
  <b>actors</b> to you.&nbsp; Thus, you (the client) have a local copy 
  of those two player actors who are running after you. </LI></UL>
<UL>
  <LI>You can see that the opponents are running toward you because the server 
  is replicating their Location <b>variable</b> to you.&nbsp; You can 
  see them animating because the server is replicating their animation 
  <b>variables</b> to you.&nbsp; In other words, the server is 
  continually feeding you new values of their Location and animation parameters, 
  at the rate of several times per second. </LI></UL>
<UL>
  <LI>You can hear their gunshots because the server is 
  <b>replicating</b> the ClientHearSound <b>function</b> to 
  you.&nbsp; The ClientHearSound function is called for a PlayerPawn whenever 
  that PlayerPawn hears a sound. </LI></UL>

<p>So, by this point, the low-level mechanisms by which Unreal multiplayer games 
operate should be clear.&nbsp; The server is updating the <b>game 
state</b> and making all of the big game decisions.&nbsp; The server is 
replicating some actors to clients. &nbsp; The server is replicating some 
variables to clients.&nbsp; And, the server is replicating some function calls 
to clients.</p>

<p>It should also be clear that not all actors need to be replicated.&nbsp; For 
example, if an actor is halfway across the level and way out of your sight, you 
don't need to waste bandwidth sending updates about it.&nbsp; Also, all 
variables don't need to be updated. &nbsp; For example, the variables that the 
server uses to make AI decisions don't need to be sent to clients; the clients 
only need to know about their display variables, animation variables, and 
physics variables.&nbsp; Also, most functions executed on the server shouldn't 
be replicated. Only the function calls that result in the client seeing or 
hearing something need to be replicated.&nbsp; So, in all, the server contains a 
huge amount of data, and only a small fraction of it matters to the client--the 
ones which affect things the player sees, hears, or feels.</p>

<p>Thus, the logical question is, "How does the Unreal engine know what actors, 
variables, and function calls need to replicated?"</p>

<p>The answer is, the programmer who writes a script for an actor is responsible 
for determining what variables and functions, in that script, need to be 
replicated. &nbsp; And, he is responsible for writing a little piece of code 
called a "replication statement", in that script, to tell the Unreal engine what 
needs to be replicated under what conditions.&nbsp; For a real-world example, 
consider some of the things defined in the Actor class. 
<UL>
  <LI>The Location variable (a vector) contains the actor's location.&nbsp; The 
  server is responsible for maintaining the location, so the server needs to 
  send that to clients. &nbsp; So the replication condition basically says 
  "Replicate this if I am the server". </LI></UL>
<UL>
  <LI>The Mesh variable (an object reference) references the mesh that should be 
  rendered for the actor.&nbsp; The server needs to send that to clients, but it 
  only needs to be sent if the actor is being rendered as a mesh, i.e. if the 
  actor's DrawType is DT_Mesh. So the replication condition basically says 
  "Replicate this if I am the server and the DrawType is DT_Mesh". </LI></UL>
<UL>
  <LI>In the PlayerPawn class, there are a bunch of boolean variables that 
  define keypresses and button presses, such as bFire and bJump.&nbsp; These are 
  generated on the client side (where the input happens), and the server needs 
  to know about them.&nbsp; So the replication condition basically says 
  "Replicate this if I am a client". </LI></UL>
<UL>
  <LI>In the PlayerPawn class, there is a ClientHearSound function that tells 
  the player that she hears a sound.&nbsp; It's called on the server but, of 
  course the sound needs be heard by the actual person playing the game, who is 
  on the client side.&nbsp; So the replication condition for this function might 
  be "Replicate this if I am the server". </LI></UL>

<p>From the above examples, several things should be apparent.&nbsp; First of 
all, every variable and function that might be replicated needs to have a 
"replication condition" attached to it, that is, an expression which evaluates 
to True of False, depending on whether the thing needs to be replicated.&nbsp; 
Second, these replication conditions need to be two-way: the server needs to be 
able to replicate variables and functions to the client, <EM>and</EM> the client 
needs to be able to replicate them to the server.&nbsp; Third, these 
"replication conditions" can be complex, such as "Replicate this if I'm the 
server and my DrawType is DT_Mesh".</p>
<p>Therefore, we need a general-purpose way of expressing (complex) conditions 
under which variables and functions should be replicated.&nbsp; What is the best 
way to express these conditions?&nbsp; We looked at all of the options, and 
concluded that UnrealScript--which is already a very powerful language for 
authoring classes, variables, and code--would be a perfect tool for writing 
replication conditions.</p>

<b>The UnrealScript Replication Statement</b>

<p>In UnrealScript, every class can have one <b>replication 
statement</b>. &nbsp; The replication statement contains one or more 
<b>replication definitions</b>. &nbsp; Each <b>replication 
definition</b> consist of a <b>replication condition</b> (a 
statement that evaluates to True or False), and a list of one or more functions 
and variables to which the condition applies.</p>

<p>The replication statement in a class may only refer to variables defined in 
that class, and functions defined first in that class (that is, it cannot apply 
to functions defined in a superclass but overridden in that class).&nbsp; This 
way, if the Actor class contains a variable DrawType, then you know where to 
look for its replication condition: it can only reside there in the Actor 
class.</p>

<p>It's valid for a class to not contain a replication statement; this simply 
means that the class doesn't define any new variables or functions that need to 
be replicated. &nbsp; In fact, most classes do not need replication statements 
because most of the "interesting" variables that affect display are defined in 
the Actor class, and are only modified by subclasses.&nbsp; In Unreal, we have 
about 500 classes, and only about 10 of them need replication statements.</p>

<p>If you define a new variable or function in a class, but you don't list it in 
a <b>replication definition</b>, that means that your variable or 
function is <EM>absolutely never replicated</EM>.&nbsp; This is the norm; most 
variables and functions don't need to be replicated.</p>

<p>Here is an example of the UnrealScript syntax for the <b>replication 
statement</b>. This is taken from the Pawn class:</p>

<PRE>replication
{
	// Variables the server should send to the client.
	reliable if( Role==ROLE_Authority )
		Weapon;
	reliable if( Role==ROLE_Authority &amp;&amp; bNetOwner )
		 PlayerName, Team, TeamName, bIsPlayer, CarriedDecoration, SelectedItem,
		 GroundSpeed, WaterSpeed, AirSpeed, AccelRate, JumpZ, MaxStepHeight,
		 bBehindView;
	unreliable if( Role==ROLE_Authority &amp;&amp; bNetOwner &amp;&amp; bIsPlayer &amp;&amp; bNetInitial )
		ViewRotation;
	unreliable if( Role==ROLE_Authority &amp;&amp; bNetOwner )
		Health, MoveTarget, Score;

	// Functions the server calls on the client side.
	reliable if( Role==ROLE_Authority &amp;&amp; RemoteRole==ROLE_AutonomousProxy )
		ClientDying, ClientReStart, ClientGameEnded, ClientSetRotation;
	unreliable if( Role==ROLE_Authority )
		ClientHearSound, ClientMessage;
	reliable if( Role&lt;ROLE_Authority )
		NextItem, SwitchToBestWeapon, bExtra0, bExtra1, bExtra2, bExtra3;

	// Input sent from the client to the server.
	unreliable if( Role&lt;ROLE_AutonomousProxy )
		bZoom, bRun, bLook, bDuck, bSnapLevel, bStrafe;
	unreliable always if( Role&lt;=ROLE_AutonomousProxy )
		bFire, bAltFire;
}</PRE>

<p>The key things you see here are: 
<UL>
  <LI>The replication statement is enclosed by "replication {}". 
  <LI>Each replication definition begins with "reliable if (condition)" or 
  "unreliable if (condition)". </LI></UL>

<b>Reliable vs. Unreliable</b>

<p>Functions replicated with the "unreliable" keyword are not guaranteed to 
reach the other party and, if they do reach the other party, they may be 
received out-of-order.&nbsp; The only things which can prevent an unreliable 
function from being received are network packet-loss, and bandwidth 
saturation.&nbsp; So, you need to understand the odds, which we will grossly 
approximate here.&nbsp; The results vary wildly among different types of 
network, so we can make no guarantees: 
<UL>
  <LI>In a LAN game, we guesstimate that unreliable data is received 
  successfully approximately 99% of the time.&nbsp; However, in the course of a 
  game, hundreds of thousands of things are replicated, so you can be sure that 
  some unreliable data will be lost.&nbsp; Therefore, even if you're aiming for 
  LAN performance only, your code needs to handle your unreliably replicated 
  variables gracefully in the case that they are lost over the wire. </LI></UL>
<UL>
  <LI>In a typical low quality 28.8K ISP connection, unreliable data is 
  generally received 90%-95% of the time.&nbsp; In other words, it is very 
  frequently lost. </LI></UL>

<p>To get a better feeling for the tradeoffs between reliable and unreliable 
functions, check out the replication statements in the Unreal scripts, and gauge 
their importance vs. the reliability decision we made.</p>

<b>Variables are always reliable</b>

<p>The "reliable" and "unreliable" keywords are ignored for variables. &nbsp; 
Variables are always guaranteed to reach the other party eventually, even under 
packet-loss and bandwidth saturation conditions.&nbsp; Changes in such variables 
are not guaranteed to reach the other party in the same order in which they were 
sent.</p>

<b>Summary</b>

<p>Here, we have documented the syntax of the replication statement thoroughly, 
without saying much about the meaning of the expressions like 
"Role==ROLE_Authority" and "bNetOwner".&nbsp; This is covered in the next 
section.</p>

<b>Replication Conditions</b>

<p>Here is a simple example of a replication condition within a class's 
script:</p>

<PRE>replication
{
	reliable if( Role==ROLE_Authority )
		Weapon;
}</PRE>

<p>This replication condition, translated into English, is "If the value of this 
actor's Role variable is equal to ROLE_Authority, then this actor's Weapon 
variable should be reliably replicated to all clients for whom this actor is 
relevant".</p>

<p>A replication condition may be any expression that evaluates to a value of 
True or False (that is, a boolean expression). So, any expression you can write 
in UnrealScript will do--including comparing variables, calling functions, and 
combining conditions using the boolean !, &amp;&amp;, ||, and ^^ operators.</p>

<p>An actor's Role variable generally describes how much control the local 
machine has over the actor.&nbsp; ROLE_Authority means "this machine is the 
server, so it is completely authoritative over the proxy actor".&nbsp; 
ROLE_SimulatedProxy means "this machine is a client, and it should simulate 
(predict) the physics of the actor". ROLE_DumbProxy means "this machine is a 
client and it should not do any simulation on this proxy actor". Role is 
described in more detail in a later section, but the quick summary is this: 
<UL>
  <LI>if ( Role==ROLE_Authority ): means "If I am the server, I should replicate 
  this to clients". 
  <LI>if( Role&lt;ROLE_Authority ): means "If I am a client, I should replicate 
  this to the server. </LI></UL>

<p>The following variables are very often used in replication statements because 
of their high utility: 
<UL>
  <LI>bIsPlayer: Whether this actor is a player.&nbsp; Is True for players, 
  false for all other actors. 
  <LI>bNetOwner: Whether this actor is owned by the client for whom the 
  replication condition is being evaluated.&nbsp; For example, say Fred is 
  holding a DispersionPistol, and Bob isn't holding any weapon. When the 
  DispersionPistol is being replicated to Fred, its bNetOwner variable will be 
  True (because Fred owns the weapon). When it is being replicated to Bob, its 
  bNetOwner variable will be False (because Bob does not own the weapon). 
  <LI>bNetInitial: Valid only on the server side, i.e. if Role==ROLE_Authority. 
  &nbsp; Indicates whether this actor is being replicated to the client for the 
  first time. &nbsp; This is useful for clients with Role==ROLE_SimulatedProxy, 
  because it enables the server to sent their location and velocity just once, 
  with the client subsequently predicting it. </LI></UL>

<p>Replication condition guidelines: 
<UL>
  <LI>Since variables are typically replicated <EM>one-way</EM> (either from the 
  client to the server, or from the server to the client, but never both), all 
  replication conditions generally start with a comparison of Role or 
  RemoteRole, i.e. if( Role==ROLE_Authority ) or if( 
  RemoteRole&lt;ROLE_SimulatedProxy ).&nbsp; If a replication condition doesn't 
  contain a comparison of Role or RemoteRole, there is probably something wrong 
  with it. 
  <LI>Replication conditions are evaluated very, very frequently on the server 
  during network play. Keep them as simple as possible, but no simpler. 
  <LI>While replication conditions are allowed to call functions, try to avoid 
  that because it could be a big slowdown. 
  <LI>Replication conditions shouldn't have any side-effects, because the 
  network code may choose to call them at any time including times when you 
  don't expect.&nbsp; For example if you do something like if( Counter++ &gt; 10 
  )..., good luck trying to figure out what the hell is going to happen.. 
</LI></UL>

<b>Variable Replication</b>

<b>Update mechanism</b>

<p>After every <b>tick</b>, the client and the server check out all 
actors in their <b>relevant set</b>. All of their replicated variables 
are examined to see if they have changed since the previous update, and the 
variables' replication conditions are evaluated to see if the variables need to 
be sent.&nbsp; As long as there is bandwidth available in the connection, those 
variables are sent across the network to the other machine.</p>

<p>Thus, the client receives updates of the "important" events that are 
happening in the world, which are visible or audible to that client.&nbsp; The 
key points to remember about variable replication are: 
<UL>
  <LI>Variable replication occurs only after a <b>tick</b> completes. 
  &nbsp; Therefore, if in the duration of a <b>tick</b>, a variable 
  changes to a new value, and then it changes back to its original value, then 
  that variable will not be replicated.&nbsp; Thus, clients only hear about the 
  state of the server's actor's variables after its tick completes; the state of 
  the variables during the tick is invisible to the client. 
  <LI>Variables are only replicated when they change, relative to their 
  previously known value. 
  <LI>Variables for an actor are only replicated to a client when they are in 
  the client's <b>relevant set</b>. Thus, the client does not have 
  accurate variables for actors that are not in his relevant set. 
  <LI>UnrealScript has no concept of global variables; so they only variables 
  that can be replicated are instance variables belonging to an actor. </LI></UL>

<b>Variable type notes</b>

<UL>
  <LI>Vectors and Rotators: To improve bandwidth efficiency, Unreal quantizes 
  the values of vectors and rotators.&nbsp; The X,Y,Z components of vectors are 
  converted to 16-bit signed integers before being sent, thus any fractional 
  values or values out of the range -32768..32767 are lost.&nbsp; The 
  Pitch,Yaw,Roll components of vectors are converted to bytes, of the form 
  (Pitch&gt;&gt;8)&amp;255.&nbsp; So, you need to be careful with vectors and 
  rotators. If you absolutely must have full precision, then use int or float 
  variables for the individual components; all other data types are sent with 
  their complete precision. 
  <LI>General structs are replicated by sending all of their components.&nbsp; A 
  struct is sent as an "all or nothing" type of thing. 
  <LI>Arrays of variables can be replicated, but only of the size of the array 
  (in bytes) is less than 448 bytes. 
  <LI>Arrays are replicated efficiently; if a single element of a large array 
  changes, only that element is sent. </LI></UL>

<b>Function Call Replication</b>

<b>Remote Routing Mechanism</b>

<p>When an UnrealScript <b>function</b> is called during a network 
game, and that function has a <b>replication condition</b>, the 
condition is evaluated and execution progresses as follows: 
<UL>
  <LI>If the function's replication condition evaluates to 
  <b>True</b>, the function call is sent to the machine on the other 
  side of the network connection for execution. &nbsp; In other words, the 
  function's name, and all of its parameters, are crammed together into a packet 
  of data, and transmitted to the other machine for later execution. &nbsp; When 
  this occurs, the function returns immediately and execution continues on. 
  &nbsp; If the function were declared to return a value, then its return value 
  is set to zero (or the equivalent of zero in some other type, i.e. 0,0,0 for 
  vectors, None for objects, etc). Any out parameters are left unaffected. In 
  other words, UnrealScript never sits around <EM>waiting for a replicated 
  function call to complete</EM>, so it can never <EM>deadlock</EM>. &nbsp; 
  Rather, replicated function calls are sent off for the remote machine to 
  execute, and the local code continues executing. </LI></UL>
<UL>
  <LI>If the <b>replication condition</b> evaluates to False, the 
  function is executed normally on the local machine. </LI></UL>

<p>Unlike replicated variables, a function call on an actor can only be 
replicated to the player who owns that actor.&nbsp; So, replicated functions are 
only useful in subclasses of PlayerPawn (i.e. players, who own themselves) and 
subclasses of Inventory (i.e. weapons and pickup items, who are owned by the 
player who is currently carrying them). That is to say, a function call can only 
be replicated to one actor (the player who owns it); they cannot be 
multicast.</p>

<p>Unlike replicated variables, replicated function calls are sent to the remote 
machine immediately when they are called, and they are always replicated 
regardless of bandwidth. &nbsp; Thus, it is possible to flood the available 
bandwidth if you make too many replicated function calls.&nbsp; Replicated 
functions suck away <EM>however much bandwidth is available</EM>, and then 
whatever bandwidth is left over is used for replicating variables.&nbsp; 
Therefore, if you flood the connection with replicated functions, you can starve 
the variables, which visually results in not seeing other actors update, or 
seeing them update in an extremely choppy motion.</p>

<p>In UnrealScript, there are no global functions, so there is no concept of 
"replicated global functions". A function is always called <EM>in the context 
of</EM> a particular actor.</p>

<b>Replicated Function Calls vs. Replicated Variables</b>

<UL>
  <LI>Too many replicated functions can flood the available bandwidth (because 
  the are always replicated, regardless of available bandwidth), whereas 
  replicated variables automatically are throttled and parceled out according to 
  bandwidth available. </LI></UL>
<UL>
  <LI>Function calls are replicated only during UnrealScript execution when they 
  are actually called, whereas variables are replicated only at the end of the 
  current tick when no script code is executing. </LI></UL>
<UL>
  <LI>Function calls on an actor are only replicated to the client who owns that 
  actor, whereas an actor's variables are replicated to all clients for whom 
  that actor is relevant. </LI></UL>

<b>Quantization Gotchas</b>

<p>To improve bandwidth efficiency, Unreal quantizes the values of vectors and 
rotators. &nbsp; The X,Y,Z components of vectors are converted to 16-bit signed 
integers before being sent, thus any fractional values or values out of the 
range -32768..32767 are lost. &nbsp; The Pitch,Yaw,Roll components of vectors 
are converted to bytes, of the form (Pitch&gt;&gt;8)&amp;255.&nbsp; If you need 
complete accuracy on rotators and vectors, send them as individual float or int 
components.</p>

<b>Actor Roles</b>

<p>The Actor class defines the ENetRole enumeration and two variables, Role and 
RemoteRole, as follows:</p>

<PRE>// Net variables.
enum ENetRole
{
    ROLE_None,            // Means the actor is not relevant in network play.
    ROLE_DumbProxy,       // A dumb proxy.
    ROLE_SimulatedProxy,  // A simulated proxy.
    ROLE_AutonomousProxy, // An autonomous proxy.
    ROLE_Authority,       // The one authoritative version of the actor.
};
var ENetRole Role;
var(Networking) ENetRole RemoteRole;</PRE>

<p>The Role and RemoteRole variables describes how much control the local and 
remote machines, respectively, have over the actor: 
<UL>
  <LI><b>Role==ROLE_DumbProxy</b> means the actor is a temporary, 
  approximate proxy which should not simulate any physics at all.&nbsp; On the 
  client, dumb proxies just sit around and are only moved or updated when the 
  server replicates a new location, rotation, or animation information.
  <UL>
    <LI>This situation is only seen in network clients, never for network 
    servers or single-player games. </LI></UL>
  <LI><b>Role==ROLE_SimulatedProxy</b> means the actor is a temporary, 
  approximate proxy which should simulate physics and animation.&nbsp; On the 
  client, simulated proxies carry out their basic physics (linear or 
  gravitationally-influenced movement and collision), but they don't make any 
  high-level movement decisions.&nbsp; They just <EM>go</EM>.
  <UL>
    <LI>This situation is only seen in network clients, never for network 
    servers or single-player games. </LI></UL>
  <LI><b>Role==ROLE_AutonomousProxy</b> means the actor is the local 
  player. &nbsp; Autonomous proxies have special logic built in for client-side 
  prediction (rather than simulation) of movement.
  <UL>
    <LI>This situation is only seen in network clients, never for network 
    servers or single-player games. </LI></UL>
  <LI><b>Role==ROLE_Authority</b> means this machine has absolute, 
  authoritative control over the actor.
  <UL>
    <LI>This is the case for all actors in single-player games. 
    <LI>This is the case for all actors on a server. 
    <LI>On a client, this is the case for actors that were locally spawned by 
    the client, such as gratuitous special effects which are done client-side in 
    order to reduce bandwidth usage. </LI></UL></LI></UL>

<p>On the server side, all actors have Role==ROLE_Authority, and RemoteRole set 
to one of the proxy types.&nbsp; On the client side, the Role and RemoteRole are 
always the exactly reversed relative to the server's value.&nbsp; This is as 
expected from the meaning of Role and RemoteRole.</p>

<p>Most of the meaning of the ENetRole values is defined by the 
<b>replication statements</b> in the UnrealScript classes such as 
Actor and PlayerPawn.&nbsp; Here are several examples of how the replication 
statements define the meanings of the various role values: 
<UL>
  <LI>The Actor.AmbientSound variable is sent from the server to clients because 
  of this <b>replication definition</b> in the Actor class: reliable 
  if( Role==ROLE_Authority ) AmbientSound; 
  <LI>The Actor.AnimSequence variable is sent from the server to clients, but 
  only for actors rendered as meshes, because of this replication definition in 
  the Actor class: unreliable if( DrawType==DT_Mesh &amp;&amp; 
  (RemoteRole&lt;=ROLE_SimulatedProxy) ) AnimSequence; 
  <LI>The client replicates his Fire and AltFire function calls to the server 
  because of this replication definition in the PlayerPawn class:&nbsp; 
  unreliable if( Role&lt;ROLE_Authority ) Fire, AltFire; 
  <LI>The server sends clients the Velocity of all simulated proxies when they 
  are initially spawned and all moving brushes because of this replication 
  definition in the Actor class: unreliable if( (RemoteRole==ROLE_SimulatedProxy 
  &amp;&amp; (bNetInitial || bSimulatedPawn)) || bIsMover ) Velocity; </LI></UL>

<p>By studying the <b>replication statements</b> in all of the 
UnrealScript classes, you can understand the inner workings of all of the 
roles.&nbsp; There is really very little "behind-the-scenes magic" going on with 
respect to replication: At a low C++ level, the engine provides a basic 
mechanism for replicating actors, function calls, and variables.&nbsp; At the 
high UnrealScript level, the meanings of the various network roles are defined 
by specifying what variables and functions should be replicated based on the 
various roles.&nbsp; So, the meaning of the roles is almost self-defining in 
UnrealScript, with the exception of a small amount of behind-the-scenes C++ 
logic which conditionally updates physics and animation for simulated 
proxies.</p>

<b>What Exactly Is Happening Behind The Scenes</b>

<p>The answer is for licensees to do a "Find in Files" in Visual C++ for all 
occurrences of "ROLE_" in the C++ and UnrealScript files.&nbsp; While 
documentation provides a general understanding of how network roles are 
interpreted, the exact impact of roles on all aspects of the code can only be 
completely described by the source code.</p>

<b>Simulated Functions</b>

<p>On the client side, many actors exist in the form of "proxies", meaning 
approximate copies of actors created by the server, and sent to the client to 
provide a visually and aurally reasonable approximation of what the client sees 
during gameplay.</p>

<p>On the client, these proxy actors are often moving around using client-side 
physics and affecting the environment, so at any time their functions can 
potentially be called. For example, a simulated proxy TarydiumShard projectile 
might run into a dumb proxy Tree actor.&nbsp; When actors collide, the engine 
attempts to call their Touch functions to notify them of the collision.&nbsp; 
Depending on context, the client desires to execute some of these functions 
calls, but ignore others.&nbsp; For example, a Skaarj's Bump function should not 
be called on the client side, because his Bump function attempts to carry out 
gameplay logic, and gameplay logic should only occur on the server. So, the 
Skaarj's Bump function should not be called.&nbsp; However, a TarydiumShard 
projectile's Bump function should be called, because it stops the physics and 
spawns a client-side special effect actor.</p>

<p>UnrealScript functions can optionally be declared with the 
"<b>simulated</b>" keyword to give programmers fine-grained control 
over which functions should be executed on proxy actors.&nbsp; For proxy actors 
(that is, actors with Role&lt;ROLE_Authority), only functions declared with the 
"<b>simulated</b>" keyword are called. All other functions are 
skipped.</p>

<p>Here is an example of a typical simulated function:</p>

<PRE>simulated function HitWall( vector HitNormal, actor Wall )
{
        SetPhysics(PHYS_None);        
        MakeNoise(0.3);    
        PlaySound(ImpactSound);
        PlayAnim('Hit');
}
</PRE>

<p>So, "<b>Simulated</b>" means "this function should always be 
executed for proxy actors".</p>

<b>Player Prediction</b>

<b>Overview</b>

<p>If a pure client-server model were used in Unreal, player movement would be 
very laggy. &nbsp; On a connection with 300 msec ping, when you push the forward 
key, you wouldn't see yourself move for 300 msec. When you pushed the mouse 
left, you wouldn't see yourself turn for 300 msec.&nbsp; This would be really 
frustrating.</p>

<p>To eliminate client-movement lag, Unreal uses a prediction scheme similar to 
that pioneered by QuakeWorld.&nbsp; It must be mentioned that the player 
prediction scheme is implemented entirely in UnrealScript.&nbsp; It is a 
high-level feature implemented in the PlayerPawn class, rather than a feature of 
the network code: Unreal's client movement prediction is layered entirely on the 
general-purpose replication features of the network code.</p>

<b>Inner Workings</b>

<p>You can see exactly how Unreal's player prediction works by examining the 
PlayerPawn script. Since the code is somewhat complex, its workings are briefly 
described here.</p>

<p>The approach can best be described as a lock-step predictor/corrector 
algorithm. &nbsp; The client takes his input (joystick, mouse, keyboard) and 
physical forces (gravity, buoyancy, zone velocity) into account and describes 
his movement as a 3D <EM>acceleration</EM> vector.&nbsp; The client sends this 
acceleration along with various input related information and his current 
timestamp (the current value of Level.TimeSeconds on the client side) to the 
server in a replicated ServerMove function call:</p>

<PRE>function ServerMove
(
    float TimeStamp,
    float AccelX,
    float AccelY,
    float AccelZ, 
    float LocX,
    float LocY,
    float LocZ,
    byte MoveFlags, 
    eDodgeDir DodgeMove, 
    rotator Rot, 
    int ViewPitch, 
    int ViewYaw
);</PRE>

<p>Then the client calls his MoveAutonomous to perform this same identical 
movement locally, and he stores this movement in a linked list of remembered 
movements using the SavedMove class.&nbsp; As you can see, if the client never 
heard anything back from the server, the client would be able to move around 
with zero lag just as in a single-player game.</p>

<p>When the server receives a ServerMove function call (replicated across the 
network), the server carries out the exact same movement on the server 
immediately.&nbsp; It deduces the movement's DeltaTime from the current 
ServerMove's TimeStamp and the previous one's. &nbsp; In this way, the server is 
carrying out the same basic movement logic as the client.&nbsp; However, the 
server might see things slightly different than the client. &nbsp; For example, 
if there's a monster running around, the client might have thought it was in a 
different position than the server (because the client is only in rough 
approximate sync with the server). Thus, the client and the server might 
disagree about how far the client actually moved as a result of the ServerMove 
call.&nbsp; At any rate, the server is authoritative, and he is completely 
responsible for determining the client's position.&nbsp; Once the server has 
processed the client's ServerMove call, it calls the client's 
ClientAdjustPosition function which is replicated across the network to the 
client:</p>

<PRE>function ClientAdjustPosition
(
	float TimeStamp,
	name newState,
	EPhysics newPhysics,
        float NewLocX,
	float NewLocY,
	float NewLocZ,
	float NewVelX,
	float NewVelY,
	float NewVelZ
);</PRE>

<p>Now, when the client receives a ClientAdjustPosition call, he must respect 
the server's authority over his position. So, the client sets his exact location 
and velocity to that specified by the ClientAdjustPosition call.&nbsp; However, 
the position the server specifies in ClientAdjustPosition reflects the 
<EM>client's actual position at some time in the past</EM>.&nbsp; But, the 
client wants to predict where he is supposed to be <EM>at the present 
moment</EM>.&nbsp; So, now the client goes through all of the SavedMove's in his 
linked list. All moves earlier than the ClientAdjustPosition call's TimeStamp 
are discarded. All moves that occurred after TimeStamp are then re-run by 
looping through them and calling MoveAutonomous for each one.</p>

<p>This way, at any point in time, the client is always predicting ahead of what 
the server has told him by an amount of time equal to half his ping time. And, 
his local movement is not at all lagged.</p>

<b>Advantages</b>

<p>This approach is purely predictive, and it gives one the best of both worlds: 
In all cases, the server remains completely authoritative. Nearly all the time, 
the client movement simulation exactly mirrors the client movement carried out 
by the server, so the client's position is seldom corrected. Only in the rare 
case, such as a player getting hit by a rocket, or bumping into an enemy, will 
the client's location need to be corrected.</p>

<b>The GameInfo class</b>

<p>The UnrealScript GameInfo class implements the game rules.&nbsp; A server 
(both dedicated and single-player) has one GameInfo subclass, accessible in 
UnrealScript as Level.Game.&nbsp; For each game type in Unreal, there is a 
special GameInfo subclass. &nbsp; For example, some existing classes are 
DeathmatchGame, SinglePlayer, TeamGame.</p>

<p>A client in a network game does not have a GameInfo. That is, 
Level.Game==None on the client side. Clients should not be expected to have a 
GameInfo because the server implements all of the gameplay rules, and the 
generality of the code calls for the client not knowing what the game rules 
are.</p>

<p>GameInfo implements a broad set of functionality, such as recognizing players 
coming and going, assigning credit for kills, determining whether weapons should 
respawn, and so on.&nbsp; Here, we will only look at the GameInfo functions 
which are directly related to network programming.</p>

<b>InitGame</b>

<PRE>event InitGame( string[120] Options, out string[80] Error );</PRE>

<p>Called when the server (either in network play or single-player) is first 
started up. &nbsp; This gives the server the opportunity to parse the startup 
URL options.&nbsp; For example, if the server was started with "Unreal.exe 
MyLevel.unr?game=unreali.teamgame", the Options string is 
"?game=unreali.teamgame". If Error is set to a non-empty string, the game fails 
with a critical error.</p>

<b>PreLogin</b>

<PRE>event PreLogin( string[120] Options, out string[80] Error );</PRE>

<p>Called immediately before a network client is logged in.&nbsp; This gives the 
server an opportunity to reject the player.&nbsp; This is where the server 
should validate the player's password (if any), enforce the player limit, and so 
on.</p>

<b>Login</b>

<PRE>event playerpawn Login( string[32] Portal, string[120] Options, out string[80] Error, class&lt;playerpawn&gt; SpawnClass );</PRE>

<p>The Login function is always called after a call to PreLogin which does not 
return an error string.&nbsp; It is responsible for spawning the player, using 
the parameters in the Options string.&nbsp; If successful, it should return the 
PlayerPawn actor it spawned.</p>

<p>If the Login function returns None indicating that the login failed, then it 
should set Error to a string describing the error. Failing a Login should be 
used only as a last resort. If you are going to fail a login, it is more 
efficient to fail it in PreLogin rather than Login.</p>

<b>Bandwidth Performance Tips</b>

<b>Optimization goal</b>

<p>The goal here is to maximize the amount of visibly important detail that is 
sent with a given bandwidth limit.&nbsp; With the bandwidth limit determined at 
runtime, your goal in writing scripts for actors that are used in multiplayer 
games is to keep bandwidth use to a minimum.&nbsp; The techniques we use in our 
scripts include: 
<UL>
  <LI>Use ROLE_SimulatedProxy and simulated movement whenever possible.&nbsp; 
  For example, nearly all of the Unreal projectiles use 
  ROLE_SimulatedProxy.&nbsp; The one exception is the Razorjack alt-fire blades, 
  which the player can steer during gameplay, thus the server must continually 
  update the position to clients. 
  <LI>For quick special effects, spawn the special effects actors purely on the 
  client side. For example, many of our projectiles use a simulated HitWall 
  function to spawn their effects on the client-side. Since these special 
  effects are just decorative rather than affecting gameplay, there is no 
  drawback to doing them completely on the client side. 
  <LI>Fine tune the default NetPriority for each class.&nbsp; Projectiles and 
  players need to have high priorities, purely decorative effects can have lower 
  priorities.&nbsp; The defaults that Unreal provides are good first-pass 
  guesses, but you can always gain some improvement by fine-tuning them. 
  <LI>When an actor is first replicated to a client, all of its variables are 
  initialized to their <EM>class default values</EM>.&nbsp; Subsequently, only 
  variables that differ from their most recent known values are 
  replicated.&nbsp; Thus, you should design your classes so that as many 
  variables as possible are automatically set to their class defaults. &nbsp; 
  For example, if an actor always should have a LightBrightness value of 123, 
  there are two ways you can make that happen: (1) set the class default's value 
  of LightBrightness to 123, or (2) in the actor's BeginPlay function, 
  initialize LightBrightness to 123. The first approach is more efficient, 
  because the LightBrightness value will never need to be replicated. With the 
  second approach, the LightBrightness needs to be replicated each time an actor 
  first becomes relevant to the client. </LI></UL>

<b>Traffic Monitoring</b>

<p>To monitor network traffic, licensees can compile the engine with:</p>

<PRE>#define DO_SLOW_GUARD 1</PRE>

<p>This enables network statistic gathering. Then, comment out the line 
Suppress[#]=DevNetTraffic in Unreal.ini.&nbsp; Then, a complete summary of 
network data received by the machine will be written to the log. In other words, 
do this on the client side to see the data sent by the server. Do it on the 
server side to see the data sent by the client.&nbsp; The data is written to the 
log in a very verbose format, giving timestamps for all packets, along with a 
summary of all replicated actors, variables, and function calls.</p>

<b>Network Driver Implementation</b>

<b>Plug-in Network Drivers</b>

<p>Unreal's network support is generalized through a plug-in interface based on 
the C++ UNetDriver class.&nbsp; The Unreal engine deals with all networking 
issues through the UNetDriver class, and dynamically loads the appropriate 
network driver specified in Unreal.ini, which defaults to:</p>

<PRE>[Engine.Engine]
NetworkDevice=IpDrv.TcpNetDriver</PRE>

<p>Unreal's current Internet support is the UDP network driver, named 
TcpNetDriver. &nbsp; However, it is quite possible to support new kinds of 
networks by creating new subclasses of UNetDriver, and using the TcpNetDriver 
source as a guideline for how to implement the new functions. In fact, the 
Maverick Software team has created an AppleTalk driver for the Mac version of 
Unreal using this interface.</p>

<p>The network driver is responsible for opening connections, closing 
connections, sending data, and receiving unreliable data.&nbsp; However, the 
contents of the data is defined by the Unreal Wire Protocol, and is completely 
opaque to the network driver itself. &nbsp; Thus, UNetDriver has no idea what 
information it's communicating, it just sends and receives it blindly.&nbsp; Its 
characteristics are as follows: 
<UL>
  <LI>Connection-oriented. UNetDriver is responsible for maintaining a list of 
  connections defined by UNetConnection subclasses. When UNetDriver is layered 
  on top of a connectionless protocol (such as UDP), it must contain its own 
  internal logic for maintaining connections, handling their timeouts, etc. 
</LI></UL>
<UL>
  <LI>UNetDriver is packet-oriented, rather than stream-oriented.&nbsp; All data 
  sent and received through UNetDriver exists in discrete packets of size 
  0...MAX_PACKET_SIZE. </LI></UL>
<UL>
  <LI>Packets are sent unreliably.&nbsp; All reliable sending and receiving of 
  packets is performed at a higher level which is invisible to UNetDriver.&nbsp; 
  A packet sent from one machine to another might not arrive, might arrive once, 
  or might arrive multiple times. Additionally, packets might arrive out of 
  order or with significant delay. </LI></UL>
<UL>
  <LI>Packets are never corrupted.&nbsp; When a packet is received, it is 
  guaranteed that the size and contents received are identical to the size and 
  contents that were sent. </LI></UL>

<b>Internet Driver</b>

<p>Unreal's Internet support is based on UDP, the standard Internet protocol for 
unreliable, connectionless communication.&nbsp; All Unreal gameplay coordination 
between a client and server goes through one constant, unchanging pairing of UDP 
addresses (where the client and server each have a 32-bit Internet address and a 
16-bit port number). &nbsp; The default port number can be seen in 
Unreal.ini.&nbsp; </p>

<p>Thus, Unreal's UDP packets are extremely easy to proxy, and they can be 
proxied transparently without the proxy having to know anything about their 
contents.</p>

<b>Unreal Wire Protocol</b>

<p>The Unreal Wire Protocol defines the contents of packets as a stream of bits. 
&nbsp; The protocol deals with a variety of concepts, such as replicating 
variables and functions, creating actors, destroying actors, transmitting files, 
and exchanging packets reliably and unreliably (both types are used in various 
circumstances).</p>

<p>The protocol will undergo some major changes in the coming months to improve 
efficiency and reliability, so it would not be useful to document it here and 
now.</p>

<p>It must be mentioned that the protocol is closely tied to the Unreal package 
file format described in the <A href="packages.html">Package Documentation</A> so it 
will be quite difficult to parse and do anything useful with.</p>

<b>UnrealScript: UdpLink, TcpLink</b>

<p>Unreal's TcpLink and UdpLink scripts enable you to write, in UnrealScript, 
code for actors which are able to communicate with external programs.&nbsp; 
These are the optimal way of extending Unreal with cool new networking 
features.&nbsp; For example, some of the cool things one could do are: 
<UL>
  <LI>Write "event gateways" which forward events (such as players pressing 
  buttons, walking into zones, etc) to other servers. 
  <LI>Write server-side programs to interface the server to master servers, 
  statistic trackers, and so on. 
  <LI>Write server-side programs to maintain persistent player statistics or 
  inventory. For example, you could write a Java/C++ database style "player 
  account manager" program that keeps track of player names, passwords, and 
  their inventory for players. &nbsp; Then, you can write an UnrealScript class 
  to interface to the account manager by TCP or UDP and validate players that 
  are trying to log in.&nbsp; See GameInfo.Login, TcpLink, and UdpLink for 
  ideas. 
  <LI>Write client-side chat programs. </LI></UL>

<b>The Present and The Future</b>

<p>The words one might use to describe Unreal's networking architecture are 
"powerful", "general", "complex" and "hard to master".&nbsp; The architecture 
went through a tremendous amount of evolution during the game's development, to 
arrive at the current solution which is a balance between power, simplicity, and 
the pragmatic need to solve certain problems.</p>

<p>The ideal networking architecture, from an ease-of-programming standpoint, is 
the pure client-server model, where the client truly acts as a dumb rendering 
terminal, and receives a display list from the server.&nbsp; However, as 
discussed previously, the analysis of the rate of bandwidth improvement versus 
hardware improvement indicates that we live in a world where the pure 
client-server model will be impractical for the foreseeable future.</p>

<p>Thus, the ability to provide rich client-side simulation of physics and 
script execution in general is tantamount in any next-generation networking 
engine.&nbsp; In Unreal we have defined a generalized networking model based on 
the generalized replication of objects, object variables, and object function 
calls.&nbsp; This model provides rich simulation capabilities without being 
hardcoded to any particular simulation model.</p>

<p>I'm pretty sure that this broad networking architecture for Unreal is the 
right one. &nbsp; Some of the research areas I investigated while determining 
the current direction include database replication, Unix RPC, the CORBA 
distributed object model, and Java RPC. &nbsp; My general conclusion is that, 
though there are some cool ideas out there, nobody else is really pushing the 
limitations of Internet technology as much as game developers. &nbsp; The same 
can probably be said about other research areas, such as real-time 3D.</p>

<p>As for the future, there are a lot of areas where this model can be extended 
and improved.&nbsp; The addition of multicast replicated functions would 
increase the amount of simulation that can be done without variable 
replication.&nbsp;&nbsp; An extended peer proxy model could enable the creation 
of a server backbone enabling the realistic real-time flow of NPC objects 
between servers.&nbsp; The replicated object model could be extended to other 
areas of the engine, such as the user-interface and chat system.&nbsp; There is 
a tremendous amount of promise for this architecture to be applied to much 
richer, more persistent game environments such as the worlds of Ultima Online, 
while retaining the distributed, user-modifiable nature of the system.&nbsp; In 
the coming years, networking will be an extremely interesting area of game 
development.</p>

<p>-Tim Sweeney</p>

<b>End</b>

<br>
<br>
<br>

</body>
</html>
