[{"content":"Intro  Unreal network system is based on Server-Client model. If developers consider about \u0026ldquo;Replication\u0026rdquo;, game can support both singleplayer and multiplayer. UE4 Clients can not communicate without Server (p2p is not currently supported)  Struct Network Mode  ENetMode  NM_Standalone  Authoritative : true Listening : false LocalPlayer : true   NM_DedicatedServer  Authoritative : true Listening : true LocalPlayer : false   NM_ListenServer  Authoritative : true Listening : true LocalPlayer : true   NM_Client  Authoritative : false Listening : false LocalPlayer : true   NM_MAX    Role, RemoteRole  ENetRole  ROLE_None  not related with replication   ROLE_SimulatedProxy  copy of ROLE_Authority extrapolative-predicted with server values   ROLE_AutonomousProxy  copy of ROLE_Authority extrapolative-predicted with server values + local functions (e.g. player input) currently, only for possessed actor with ownership   ROLE_Authority  origin not available for NM_Client currently   ROLE_MAX    Ownership  PlayerController is root of ownership  Pawn that possessed by PlayerController and Actors owned by the Pawn is owned by the Player Subobjects owned by its outer\u0026rsquo;s owner   needed for  Client RPC destination replication relevancy  bOnlyRelevantToOwner   conditional property replication  COND_OwnerOnly, COND_InitialOrOwner, COND_SkipOwner   ROLE_AutonomousProxy to ROLE_SimulatedProxy  ROLE_AutonomousProxy is only allowed for owner client      Method Property Replication 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  class ENGINE_API AActor : public UObject { UPROPERTY( Replicated ) // originally, it\u0026#39;s ReplicatedWith specifier  AActor * Owner; UPROPERTY(EditDefaultsOnly, ReplicatedUsing=OnRep_ReplicatedMovement, Category=Replication, AdvancedDisplay) struct FRepMovement ReplicatedMovement; UFUNCTION() virtual void OnRep_ReplicatedMovement(); }; void AActor::GetLifetimeReplicatedProps( TArray\u0026lt; FLifetimeProperty \u0026gt; \u0026amp; OutLifetimeProps ) const { DOREPLIFETIME( AActor, Owner ); DOREPLIFETIME_CONDITION( AActor, ReplicatedMovement, COND_SimulatedOnly ); // check \u0026#34;UnrealNetwork.h\u0026#34; for more variations } void AActor::PreReplication( IRepChangedPropertyTracker \u0026amp; ChangedPropertyTracker ) { DOREPLIFETIME_ACTIVE_OVERRIDE( AActor, ReplicatedMovement, bReplicateMovement ); } void AActor::OnRep_ReplicatedMovement() { ... }    server to client only reliable ELifetimeCondition  COND_None COND_InitialOnly COND_OwnerOnly COND_SkipOwner COND_SimulatedOnly COND_AutonomousOnly COND_SimulatedOrPhysics COND_InitialOrOwner COND_Custom + SetCustonIsActiveOverride(...) COND_ReplayOrOwner COND_ReplayOnly COND_SimulatedOnlyNoReplay COND_SimulatedOrPhysicsNoReplay COND_SkipReplay COND_Never COND_Max   NetUpdateFrequency  and MinNetUpdateFrequency for Adaptive Network Frequency   with UPROPERTY(replicated), UObject references are replicated via FNetworkGUID  check with UObject::IsSupportedForNetwork() refernce replication occurs in one of them :  replicated actor stably named actor replicated component stably named component UObject from loaded package   \u0026ldquo;stably named\u0026rdquo; means  existing in both server and client with exactly same name actors from package are stably named (not spawned during gameplay) components under are stably named  from package added with construction script (static component) manually marked (via UActorComponent::SetNetAddressable(...))  need same name          Remote Procedure Call (RPC) 1 2 3 4 5 6 7 8 9 10 11 12 13  UFUNCTION(Server, WithValidation) void FunctionThatCalledOnServer(); UFUNCTION(Client, Reliable) void FunctionThatCalledOnOwnerClient(); UFUNCTION(NetMulticast) void FunctionThatCalledOnEveryActor(); void ClassName::FunctionThatCalledOnServer_Implementation() {} bool ClassName::FunctionThatCalledOnServer_Validation() {return true;} void ClassName::FunctionThatCalledOnOwnerClient_Implementation() {} void ClassName::FunctionThatCalledOnEveryActor_Implementation() {}    Only executed on Actor that is replicating If you want to make sure RPC executed. you should set Reliable specifier on RPC\u0026rsquo;s UFUNCTION().  RPC is Unreiiable by default. If you spam Reliable like every ticks, client may get disconnected due to preventation of DDOS.   WithValidation specifier declares _Validation function with bool return and same parameters.  _Validation function must be followed after WithValidation specifier. disconnect client if return is false execute RPC if return is true Server RPC requires WithValidation   when calling RPC on Server    actor \\ specifier none NetMulticast Server Client     Owned by client server server \u0026amp; all clients server owning client   Owned by server server server \u0026amp; all clients server server   Unowned server server \u0026amp; all clients server server     when calling RPC on Client    actor \\ specifier none NetMulticast Server Client     Owned by self self self server self   Owned by other self self none self   Owned by server self self none self   Unowned self self none self      Component Replication  tbd  Optimization Relevancy  AActor::IsNetRelevantFor()  return true : bIsAlwaysRelevant | Owned | Pawn | Instigated by Pawn return owner\u0026rsquo;s : bNetUseOwnerRelevancy \u0026amp; Owned return false : bOnlyRelevantToOwner \u0026amp; not 1. return base\u0026rsquo;s : attached to skeleton of another actor return false : bHidden \u0026amp; root component not collide  warning if there is no root component   return ture : distance based relevancy (AGameNetworkManager) \u0026amp; closer than net cull distance   Pawn and PlayerController return different result (overriding) bStatic Actors can also be replicated imperfect  large actor sound occlusion of ambient sound though, packet loss is more critical so it\u0026rsquo;s affordable    Priority  NetPriority weight for bandwidth load balancing default values  Actor = 1.0 Matinee = 2.7 Pawn = 3.0 PlayerController = 3.0   AActor::GetNetPriority() = NetPriority * replication waiting time (plus location and distance, etc)  Dormancy  ENetDormancy  DORM_Never DORM_Awake DORM_DormantAll DORM_DormantPartial + GetNetDormancy() DORM_Initial DORM_Max    NetClientTicksPerSecond  tbd  Replication Graph  tbd  Conceptual Tips  reduce bReplicates reduce NetUpdateFrequency use Dormancy use Relevancy reduce NetClientTicksPerSecond use Quantizing (e.g. FVector_NetQuantize) minimize RPC : replace into RepNotify  remove Server RPC that unused on clients reduce NetMulticast RPC reduce FName as RPC parameter don\u0026rsquo;t spam reliable RPC   check ROLE_Authority for server logic check IsLocallyControlled for owner logic  but not in constructor    Flow UNetDriver::ServerReplicateActors flow  tbd  Character Movement Component flow  tbd  Others Travelling  Seamless (non-blocking)  highly recommended   Non-Seamless (blocking)  first map loading client-to-server first connect ending game, starting new game   UEngine::Browse(...) UWorld::ServerTravel(...) APlayerController::ClientTravel(...) Transition Map  UGameMapSetting::TransitionMap AGameModeBase::bUseSeamlessTravel   Seamless Travel Flow  Mark persistent actors to transition map Travel to transition map Mark persistent actors to final map Travel to final map   Persistent actors  GameMode actor (server only)  Actors added by AGameModeBase::GetSeamlessTravelActorList   Controllers with valid PlayerState (server only) All PlayerControllers (server only) All local PlayerControllers (server and clients)  Actors added by APlayerController::GetSeamlessTravelActorList on local      Online Subsystem  tbd  Session  tbd  Online Beacons  tbd  Practical Network Profiler  tbd  Testing Multiplay  tbd  ","permalink":"https://niiok.github.io/unreal/network/","summary":"Intro  Unreal network system is based on Server-Client model. If developers consider about \u0026ldquo;Replication\u0026rdquo;, game can support both singleplayer and multiplayer. UE4 Clients can not communicate without Server (p2p is not currently supported)  Struct Network Mode  ENetMode  NM_Standalone  Authoritative : true Listening : false LocalPlayer : true   NM_DedicatedServer  Authoritative : true Listening : true LocalPlayer : false   NM_ListenServer  Authoritative : true Listening : true LocalPlayer : true   NM_Client  Authoritative : false Listening : false LocalPlayer : true   NM_MAX    Role, RemoteRole  ENetRole  ROLE_None  not related with replication   ROLE_SimulatedProxy  copy of ROLE_Authority extrapolative-predicted with server values   ROLE_AutonomousProxy  copy of ROLE_Authority extrapolative-predicted with server values + local functions (e.","title":"Unreal Network"},{"content":"Intro and Philosophy History  rendering has always been focus point best visual at the best performance all-compatible set of tools for any renderer or platform  UE1 (1997)  blended colored light dynamic, static light volumetric light, lensflare, perfect mirrors, procedural texture effects 1k, 2k supported, detailed texture in 256mb memory  UE2 (2002)  DirectX 7 support mesh, terrains, larger outdoor environments, vehicles foliage and particle basic material vertex lighting  UE3 (2006)  DirectX 9 support forward rendering even larger outdoor environments full lightmapping, dynamic shadows  UE4 (2014)  handle any style (not only high realism) scalabiliy, from indipendable to AAA over game egine  better fidelity, architecture, pipeline, flexibility    UE5 (2022)  Nanite Lumen Niagara  Schematic Schematic  Ahead of Rendering Visibility Features Start of Rendering BasePass  BasePass Material  Geometry Precomputed Lighting     GBuffer Dynamic Light \u0026amp; Shadow Reflections Additional  Translucency Atmospherics Etc   Post Processing Final Frame  Scalability and Performance    Schematic Overview Full size (4MB)\nAhead of Rendering (Frame 0, CPU) All Logic  deciding what to render\n  Gameplay Animation Physics etc..  Visibility (Frame 1, CPU)  check what can be seen by camera. process lighter tasks first to reduce calcuration candidates\n  Occlusion/Visibility Processes  Distance Culling (Lightest)  not enabled by default (recommended) by CullDistanceVolume  or you have to set Desired Max Draw Distance for every actors (annoying)     Frustum Culling  standard enabled why you have to disable this?   Precomputed Visibility  not enabled by default (optional) enable with World Setting property Good for space-time tradeoff  use memmory to reduce cpu cost   by PrecomputedVisibilityVolume   Visibility Culling (Heaviest)  standard enabled heavy check with freezerendering Hardware Occlusion  use every mesh as occluder not work in every devices (so engine need Software Occlusion)   Software Occlusion  uses Mesh LODs as occluder        Start of Rendering (Frame 2, GPU) Early Z Pass  Scene Depth used for deferred rendering pipeline  Basepass  Act of rendering all geometries can check with GPU compiler\n  Drawcalls  HLOD Static Meshes Instanced Meshes Skeletal Meshes Landscapes Procedural Meshes Geometry Collection \u0026hellip; etc (Geometry, 3D to render)   Dynamic Instancing  automatically batch drawcalls\n  enabled by default same mesh, same material in one drawcall   Basspass Materials  unreal\u0026rsquo;s deferred rendering do not render every materials at once. first, basic materials are rendered here (without shadow, blending, etc)\n  Lightmaps  need for initial shading Generated by Lightmass      Static Lighting/Shadows  Lightmass  Separeted application run by Swarm agent manage building and baking lights\n  what  Static Light Actors placed in the world Lightmass Importance Volume Global Illumination/Radiosity   how  Volumetric Lightmaps  default setting for current version saves lighting data since lightmap doesn\u0026rsquo;t provide dynamic lighitng data   Volume Lighting Samples  used for older version less memory, less gpu time, less accuracy saves single color only for dynamic lighting data        GBuffer  Buffer A : World Normals Buffer B : Specular / Roughness / Metalic Buffer C : Base Color / Lighting Buffer D : Additional Buffer E : Additional  Dyanmic Lighting/Shadows Direct-Light  IES Profiles  customize light projection and intensity can be static   Light Functions  Material -\u0026gt; Material Domain -\u0026gt; Light Function e.g. fire flickering, water caustics, cloud shadow kinda heavy work, so set Fade Distance in proper value    Direct-Shadow  Dynamic Shadows  optionally use Mesh Distance Field cached (performance dip when invalidated) r.Shadow.CacheWholeSceneShadows   Cascaded Shadow Maps  for gradually disappearing shadows low, medium, high quality (3 by default) commonly used in directional light, outdoor environments still heavy, ugly when shadow disappear -\u0026gt; Distance Field Shadows   Distance Field Shadow  not enabled by default uses Mesh Distance Field need more memory and imprecise   Raytraced Shadows Per Object Shdows \u0026amp; Inset Shadows  used for often-seen shadows (like character mesh) can show more precise shadow   Contact Shadows  shadow over close obejcts kind of post processing for tiny detail    Indirect-Light  both are not commonly used for nowdays\n  Light Propagation  older realtime GI outdated; not recommended   Raytraced GI  complication of raytracing feature complex works    Indirect-Sahdow  Raycast AO  raycast feature Accurate raytraced Ambient Occlusion (a.k.a. its name)   Capsule Shadow  simplicating skeletal mesh shadows commonly used for tiny creatures or massive characters can be used for vague light art style   DFAO  Distance Field Ambient Occlusion uses Mesh Distance Field used for moveable. stationary Skylight (in detail panel) let actor scale stay close to 1, or Distance Field will look weird    Reflections Additional Post Processing Final Frame (Frame N, ) Performance Scalability Example Plugin : RenderDoc\n data,  Advice ","permalink":"https://niiok.github.io/unreal/sjoerddejong/kickstart_rendering/","summary":"Intro and Philosophy History  rendering has always been focus point best visual at the best performance all-compatible set of tools for any renderer or platform  UE1 (1997)  blended colored light dynamic, static light volumetric light, lensflare, perfect mirrors, procedural texture effects 1k, 2k supported, detailed texture in 256mb memory  UE2 (2002)  DirectX 7 support mesh, terrains, larger outdoor environments, vehicles foliage and particle basic material vertex lighting  UE3 (2006)  DirectX 9 support forward rendering even larger outdoor environments full lightmapping, dynamic shadows  UE4 (2014)  handle any style (not only high realism) scalabiliy, from indipendable to AAA over game egine  better fidelity, architecture, pipeline, flexibility    UE5 (2022)  Nanite Lumen Niagara  Schematic Schematic  Ahead of Rendering Visibility Features Start of Rendering BasePass  BasePass Material  Geometry Precomputed Lighting     GBuffer Dynamic Light \u0026amp; Shadow Reflections Additional  Translucency Atmospherics Etc   Post Processing Final Frame  Scalability and Performance    Schematic Overview Full size (4MB)","title":"Unreal Kickstart - Rendering"},{"content":"Intro and Philosophy History  visual based complete toolset level centric started from level editor other tools added-on level editor, and then it called as engine  UE1 (1997/1999)  Called as UnrealEd1, UnrealEd2 BSP Brush focused Engine struct was formulated  Actors, Viewport, Camera controls, toolbar\u0026hellip; Lighting rendered in viewport   Event/Tag scripted Subtractive world (Skybox)  UE2 (2002)  Meshes added  BSP-Mesh hybrid workflow   Event/Tag scripted Subtractive world (Skybox) used Ctrl+S to subtract (prevent spam)  UE3 (2006)  Visual scripting (Kismet) added sub-editors added  Matinee, Cascade, Material editor, etc   Additive world (no Skybox) UE4\u0026rsquo;s structure was almost completed  UE4 (2014)  Blueprint added UI revamp 2nd generation sub-editors and tools  Matinee and Cascade are replaced Sequencer, Sound cue editor, etc Unified interface with blueprint    UE5 (2022)  Reinforced sub-editors and open world support  Chaos, AFPA, World Partition, etc    Schematic-Schematic  All required tools and sub-editors are part of the editor and engine.\n  for same team, same style, same logic to work together seamlessly   WYSIWYG\n  fully visual not text based scripting/programming  not only for programmers speed up world production  posititate experimentation, qualty, diversity      Schematic Overview Full size (4MB)\nPlacable Actors excluding 3D  Audio Actors Emitter Actors  Cascade particle or Niagara particle   Reflection Captures  Sphere, Box, Planar   Light Actors  Point, Rectangular, Spot, Directional, Sky Static, Stationary, Dynamic(Movable)   Volumes  Represent Area of something or somewhat, somehow Geometry Editing available   BP Actors  Used for both Gameplay and Workflow (not only for programmers)   Gameplay/Other  Trigger, Maker, Spawn(e.g. player start), Decal, etc    Placable 3D Actors  Static Meshes  without some exceptions(e.g. vertex shader), theres no change like bone animation HLOD : composit meshes into one, so that reduce drawcall Instanced Static Meshes : Batching meshes to render Splines : revole/deform static mesh   Skeletal Meshes  Meshes with bone   Geometry  Geometry Editing available Binary Space Partition (BSP) almost deprecated   Procedural Mesh  available with plugin generated at runtime   Foliage  Foliage Tool  automatically batched   Grass  automatically generated by landscape material layer uses landscape\u0026rsquo;s lighting (good for performance)   Procedural Foliage  experimental automatically generated in foliage volume foliage type (imitate real nature)     Geometry Collections  Chaos Destructibles   Landscapes  Layer, Components, Gizmos, Visibility, Painting, Sculpting, etc Landscape Splines Landmass Plugin  Landscape Brushes     Skies  Static mesh and Material new : Physical based Sky Atmosphere    3D Tools  Import Modeling Tools  Sculpting Tools   UV Tools Mesh Simplification  can be used for generating LOD    Controls the Level  World Properties Level Blueprint  Timeline good for simple animations(changes)   Variants Manager  can assign any property ce on console to test   Sequencer  used for movie or cutscene can handle almost kind of values Sequence Template    Rebuilding  Lighting  Lightmass Importance Volume  Lightmaps Volumetric Lightmaps   Precomputed Visibility   HLOD Reflection Captures Navmesh  Navmsh Agent \u0026ldquo;Build Paths\u0026rdquo; Runtime Navmesh (not pre-built)    Sub-Level For  great for co-work Devide by location Devide by actor type Light Scenarios  set different lights in individual sublevels    How to load  Blueprint (LoadStreamLevel)  also code   Volumes Always Loaded World Composition  load automatically by instigator\u0026rsquo;s distance (x and y, but not z) good for open world    Performance  Stats  since UE2 type stat [command] in console e.g. scenerendering, none, game, physics, FPS, unit   GPU Profiler  Ctrl + Shift + , or Profile GPU to open   Statistics Panel  good for performance optimizing   View Modes  can check complexity   Cull/Max Draw Distance Scalability World Detail  since UE1 or UE2 can tag visual effects with rate    Advice   Multi user editing is available with editor server\n without source controls    Level organization\n Important actor standards  Editor Billdboard Scale   Outliner  since UE4 (not familiar with old devs)   Groups  Ctrl Shift G doesn\u0026rsquo;t affect on rendering and outliner (not batch)   Layers  actually not layer one actor can be contained in multiple layers useful for selecting   Selection tools  right clikc on actor for a lot of options Ctrl + B open mesh in content browser  asset action   can select in Statistics Panel too      Level cleanliness\n Rotation and scale Grid and snapping  can customize snap unit Brackets(snap unit in/decrease) are good shortcut for preventing movement mistake   Shadows/Collision    Landscapes\n LOD and Collision Component setting Material complexity change and Shared Sampler Distance Fading scale/textures Hard blends    Foliage\n Foliage Assets Range and Shadow  removing shadow is recommended reducing rendering range is recommended   Lower position material trick  cognitive trick   Slope material trick    Painting Tools\n it\u0026rsquo;s material tricks    Questions\n is light mass volume needed in raytrace?  not need in fully dynamic lights but raytrace is not every-solution   co-working on sublevel  sublevel can share same transform      ","permalink":"https://niiok.github.io/unreal/sjoerddejong/kickstart_world/","summary":"Intro and Philosophy History  visual based complete toolset level centric started from level editor other tools added-on level editor, and then it called as engine  UE1 (1997/1999)  Called as UnrealEd1, UnrealEd2 BSP Brush focused Engine struct was formulated  Actors, Viewport, Camera controls, toolbar\u0026hellip; Lighting rendered in viewport   Event/Tag scripted Subtractive world (Skybox)  UE2 (2002)  Meshes added  BSP-Mesh hybrid workflow   Event/Tag scripted Subtractive world (Skybox) used Ctrl+S to subtract (prevent spam)  UE3 (2006)  Visual scripting (Kismet) added sub-editors added  Matinee, Cascade, Material editor, etc   Additive world (no Skybox) UE4\u0026rsquo;s structure was almost completed  UE4 (2014)  Blueprint added UI revamp 2nd generation sub-editors and tools  Matinee and Cascade are replaced Sequencer, Sound cue editor, etc Unified interface with blueprint    UE5 (2022)  Reinforced sub-editors and open world support  Chaos, AFPA, World Partition, etc    Schematic-Schematic  All required tools and sub-editors are part of the editor and engine.","title":"Unreal Kickstart - World Building"},{"content":"About this kickstart  Kickstart for giving Big picture perspective of UE4 Not a step-by-step walkthrough of how to use UE4 about what, why, terminology, logic, history plus advices and practises for beginners  Composed with  Philosophy and Intro Schematic Overview Advice  Presenters Sjoerd De Jong  Evangelism Lead Europe 20 Years experience with UE1-4 Anything content or Blueprint related except for Animation/Audio  Mario Palmero  8 hours years experience with UE3-4 Programming, Tech Art and Animation  Contents World Building Rendering Animation Engine Structure Programming Blueprint Character Material ","permalink":"https://niiok.github.io/unreal/sjoerddejong/kickstart/","summary":"About this kickstart  Kickstart for giving Big picture perspective of UE4 Not a step-by-step walkthrough of how to use UE4 about what, why, terminology, logic, history plus advices and practises for beginners  Composed with  Philosophy and Intro Schematic Overview Advice  Presenters Sjoerd De Jong  Evangelism Lead Europe 20 Years experience with UE1-4 Anything content or Blueprint related except for Animation/Audio  Mario Palmero  8 hours years experience with UE3-4 Programming, Tech Art and Animation  Contents World Building Rendering Animation Engine Structure Programming Blueprint Character Material ","title":"Unreal Kickstart"},{"content":"Core Nanite Lumen Open World File per Actor World Partition Data Layer Level Instance Large World Coordinate ","permalink":"https://niiok.github.io/unreal/ue5_new/","summary":"Core Nanite Lumen Open World File per Actor World Partition Data Layer Level Instance Large World Coordinate ","title":"UE5 New Features"},{"content":"Intro  Subsystem is handy and useful instance with various lifecycle. Every Subsystems declared as class will be instanced and called Inintialize() and Deinitialize() in proper time. Thanks to Subsystems, GameInstance don\u0026rsquo;t have to be over-responsible. (and other massive advantages)  Subsystem variety   UEngineSubsystem\n Lifetime : StartUp() ~ ShutDown() Reference : GEngine-\u0026gt;GetEngineSubsystem\u0026lt;T\u0026gt;();    UEditorSubsystem\n Lifetime : StartUp() ~ ShutDown() Reference : GEditor-\u0026gt;GetEditorSubsystem\u0026lt;T\u0026gt;();    UGameInstanceSubsystem\n Lifetime : Same with GameInstance Reference : [GameInstance]-\u0026gt;GetSubsystem\u0026lt;T\u0026gt;();    ULocalPlayerSubsystem\n Lifetime : Same with LocalPlayer Reference : [LocalPlayer]-\u0026gt;GetSubsystem\u0026lt;T\u0026gt;();    Online Subsystem? ","permalink":"https://niiok.github.io/unreal/subsystem/","summary":"Intro  Subsystem is handy and useful instance with various lifecycle. Every Subsystems declared as class will be instanced and called Inintialize() and Deinitialize() in proper time. Thanks to Subsystems, GameInstance don\u0026rsquo;t have to be over-responsible. (and other massive advantages)  Subsystem variety   UEngineSubsystem\n Lifetime : StartUp() ~ ShutDown() Reference : GEngine-\u0026gt;GetEngineSubsystem\u0026lt;T\u0026gt;();    UEditorSubsystem\n Lifetime : StartUp() ~ ShutDown() Reference : GEditor-\u0026gt;GetEditorSubsystem\u0026lt;T\u0026gt;();    UGameInstanceSubsystem","title":"Unreal Subsystem"},{"content":"To package apk successfully via Android Studio (UE4.25~)  First, follow this official document. Tips below may be useful if your Gradle spit errors out. (wrote in 2022 March with UE4.27.2)  Check existence of these 2 files (Windows)  Users/[User name]/AppData\\Local\\Android\\Sdk\\build-tools\\[SDK version]/dx.bat Users/[User name]/AppData\\Local\\Android\\Sdk\\build-tools\\[SDK version]/lib/dx.jar   If they don\u0026rsquo;t exist, make symbolic links of d8.bat and d8.jar. You MUST enable AndroidDeviceProfileSelector and AndroidPermission plugins. Then execute [EngineFolder]/Engine/Extras/Android/SetupAndroid.* while UE4 and Android Studio are off.    ","permalink":"https://niiok.github.io/unreal/android_packaging/","summary":"To package apk successfully via Android Studio (UE4.25~)  First, follow this official document. Tips below may be useful if your Gradle spit errors out. (wrote in 2022 March with UE4.27.2)  Check existence of these 2 files (Windows)  Users/[User name]/AppData\\Local\\Android\\Sdk\\build-tools\\[SDK version]/dx.bat Users/[User name]/AppData\\Local\\Android\\Sdk\\build-tools\\[SDK version]/lib/dx.jar   If they don\u0026rsquo;t exist, make symbolic links of d8.bat and d8.jar. You MUST enable AndroidDeviceProfileSelector and AndroidPermission plugins. Then execute [EngineFolder]/Engine/Extras/Android/SetupAndroid.* while UE4 and Android Studio are off.","title":"Android packaging"},{"content":" strlen()  1 2 3 4 5 6 7 8 9  int strlen (char s[]) { int i; i = 0; while ( s[i] != \u0026#39;\\0\u0026#39; ) ++i; return i; }    memset()  1  void* memset(char s[], char c, int n);    place character c into first n characters of s, return s.\n ","permalink":"https://niiok.github.io/c/array_string/","summary":" strlen()  1 2 3 4 5 6 7 8 9  int strlen (char s[]) { int i; i = 0; while ( s[i] != \u0026#39;\\0\u0026#39; ) ++i; return i; }    memset()  1  void* memset(char s[], char c, int n);    place character c into first n characters of s, return s.\n ","title":"Array String"},{"content":"File name  fully lower-case word separation expressed as _ (underscore)  1 2  file_name.txt very_good_source_code.c   Type name  start with capital letter next letters are lower-case word separation expressed as upper-cased first letter  1 2  class SuperDuperClass{}; struct TypeNameExpressedLikeThis{};   Variable name   function parameters are included in variable\n  Common variable name\n fully lower-case space expressed into _ (underscore)  1 2  int integer_variable = 4; int quantity_of_cookies = 0;     Class data member name\n same with common variable name, but has tailing _ (underscore)  1 2 3 4 5 6  class SampleClass { private: int class_member_; float x_, y_; };     Struct data member name\n fully same with common variable name  1 2 3 4 5  struct SampleStruct { int struct_member; float x, y; };     Constant name  start with k word separation expressed as upper-cased first letter if you can\u0026rsquo;t use uppercase spacing, _ (underscore) is allowed that time  1 2  const int kMagicNumber = 42; const int kAndroid8_0_0 = 24;   Function name  start with capital letter word separation expressed as upper-cased first letter some functions like accessors and mutators can be named like variable.  1 2 3 4 5  MoveToThere(); ScoreCount(); get_name(); set_name(); size();   NameSpace name  fully lower-case word separation expressed as _ (underscore)  1 2  namespace countryside_bus {} namespace project_goo {}   Enumerator name  enum follows Constant naming rule not Macro naming rule  1 2 3 4 5  enum Fruits { kBanana, kApple, kCherry };   Macro name  fully CAPITAL LETTER word separation expressed as _ (underscore)  1 2  #define PI 3.14 #define ARRAY_SIZE 32   Some Exceptions If you are naming something that is analogous to an existing C or C++ entity then you can follow the existing naming convention scheme.\n bigopen()  function name, follows form of open()   uint  typedef   bigpos  struct or class, follows form of pos   sparse_hash_map  STL-like entity; follows STL naming conventions   LONGLONG_MAX  a constant, as in INT_MAX    ","permalink":"https://niiok.github.io/cpp/naming/","summary":"File name  fully lower-case word separation expressed as _ (underscore)  1 2  file_name.txt very_good_source_code.c   Type name  start with capital letter next letters are lower-case word separation expressed as upper-cased first letter  1 2  class SuperDuperClass{}; struct TypeNameExpressedLikeThis{};   Variable name   function parameters are included in variable\n  Common variable name\n fully lower-case space expressed into _ (underscore)  1 2  int integer_variable = 4; int quantity_of_cookies = 0;     Class data member name","title":"Cpp Naming rule"},{"content":"  CWnd (Window Support)\n CFrameWnd (Frame Windows)  CMDIChildWnd  (user MDI windows)   CMDIFrameWnd  (user MDI workspaces)   CMiniFrameWnd (user SDI windows) COleIPFrameWnd   CSplitterWnd CControlBar (Control Bars)  CDialogBar COleResizeBar CReBar CStatusBar CToolBar   CPropertySheet (Property Sheets) CDialog (Dialog Boxes)  CCommonDialog  CColorDialog CFileDialog CFindReplaceDialog CFontDialog COleDialog  COleBusyDialog COleChangeIconDialog COleChangeSourceDialog COleConvertDialog COleInsertDialog COleLinksDialog  COleUpdateDialog   COlePasteSpecialDialog COlePropertiesDialog   CPageSetupDialog CPrintDialog CPrintDialogEx   COlePropertyPage CPropertyPage (user dialog boxes) CDHtmlDialog  CMultiPageDHtmlDialog     CView (Views)  CCtrlView  CEditView CListView CRichEditView CTreeView   CScrollView  (user scroll views) CFormView  (user form views) CDaoRecordView CHtmlEditView CHtmlView COleDBRecordView CRecordView  (user record views)            (Controls)\n CAnimateCtrl CComboBox CDateTimeCtrl CEdit CHeaderCtrl CHtmlEditCtrl CHotKeyCtrl CIPAdressCtrl CLinkCtrl CListBox CListCtrl CMonthCalCtrl COleControl CProgressCtrl CReBarCtrl CRichEditCtrl CScrollBar CSliderCtrl CSpinButtonCtrl CStatic CStatusBarCtrl CTabCtrl CToolBarCtrl CToolTipCtrl CTreeCtrl    Create()\n almost same with CreateWindow()\u0026rsquo;s method version    ","permalink":"https://niiok.github.io/windows/cwnd/","summary":"CWnd (Window Support)\n CFrameWnd (Frame Windows)  CMDIChildWnd  (user MDI windows)   CMDIFrameWnd  (user MDI workspaces)   CMiniFrameWnd (user SDI windows) COleIPFrameWnd   CSplitterWnd CControlBar (Control Bars)  CDialogBar COleResizeBar CReBar CStatusBar CToolBar   CPropertySheet (Property Sheets) CDialog (Dialog Boxes)  CCommonDialog  CColorDialog CFileDialog CFindReplaceDialog CFontDialog COleDialog  COleBusyDialog COleChangeIconDialog COleChangeSourceDialog COleConvertDialog COleInsertDialog COleLinksDialog  COleUpdateDialog   COlePasteSpecialDialog COlePropertiesDialog   CPageSetupDialog CPrintDialog CPrintDialogEx   COlePropertyPage CPropertyPage (user dialog boxes) CDHtmlDialog  CMultiPageDHtmlDialog     CView (Views)  CCtrlView  CEditView CListView CRichEditView CTreeView   CScrollView  (user scroll views) CFormView  (user form views) CDaoRecordView CHtmlEditView CHtmlView COleDBRecordView CRecordView  (user record views)            (Controls)","title":"CWnd"},{"content":"  FILE\n  fopen\n  1  FILE* fopen (char* name, char* mode);   used to openning file with file name name.\n  mode\n \u0026ldquo;r\u0026rdquo; : read \u0026ldquo;w\u0026rdquo; : write (will be overwrited), (make new file if it doesn\u0026rsquo;t exist and possible) \u0026ldquo;a\u0026rdquo; : append (make new file if it doesn\u0026rsquo;t exist and possible) \u0026ldquo;rb\u0026rdquo; : binary-read \u0026ldquo;wb\u0026rdquo; : binary-write (will be overwrited), (make new file if it doesn\u0026rsquo;t exist and possible) \u0026ldquo;ab\u0026rdquo; : binary-append (make new file if it doesn\u0026rsquo;t exist and possible)    getc\n  1  int getc (FILE* fp);    putc  1  int putc (int c, FILE* fp);    getchar  1  #define getchar() getc( stdin )    putchar  1  #define putchar(c) putc( (c), stdout )    fscanf  1  int fscanf (FILE* fp, char* format, ...);    fprintf  1  int fprintf (FILE* fp, char* format, ...);    fclose  1  int fclose (FILE* fp)   ","permalink":"https://niiok.github.io/c/file/","summary":"FILE\n  fopen\n  1  FILE* fopen (char* name, char* mode);   used to openning file with file name name.\n  mode\n \u0026ldquo;r\u0026rdquo; : read \u0026ldquo;w\u0026rdquo; : write (will be overwrited), (make new file if it doesn\u0026rsquo;t exist and possible) \u0026ldquo;a\u0026rdquo; : append (make new file if it doesn\u0026rsquo;t exist and possible) \u0026ldquo;rb\u0026rdquo; : binary-read \u0026ldquo;wb\u0026rdquo; : binary-write (will be overwrited), (make new file if it doesn\u0026rsquo;t exist and possible) \u0026ldquo;ab\u0026rdquo; : binary-append (make new file if it doesn\u0026rsquo;t exist and possible)    getc","title":"File"},{"content":"Introduction Writer prefer 1983 ANSI C (K\u0026amp;R 2nd).   C was born for UNIX\n C is machine independent C is simple and concise (even though program with it is complicated)    Creator\u0026rsquo;s words\n   C is a general-purpose programming language which features economy of expression, modern control flow and data structures, and a rich set of operators.\n    C wears well as one\u0026rsquo;s experience with it grows.\n    C is a relatively \u0026ldquo;low level\u0026rdquo; language.\n     standard library\n input output memory management string manipulation etc    What C provides\n data types  characters integers floating point numbers and hierarchy of derived data types created with pointers, arrays, structures, and unions   expressions are formed from operators and operands  any expression, including an assignment or a function call, cam be statement   pointers provide for machine-independent address arithmetic control-flow  statement grouping decision making (if-else) selecting one of a set of possible cases (switch) looping  with the termination test at the top (while, for) with the termination test at the bottom (do) early loop exit (break) early loop skip (continue)     Function  returns data type may be called recursively may exist in separated source files that are compiled separately   Variables  declared autoatically may be declared in block-structure may be internal to function, external but known only within source files, and conditional compilation   C is a relatively \u0026ldquo;low level\u0026rdquo; language  deals with characters, numbers, and addresses there are no operations that manipulate an entire array or string  although structures may be copied as a unit   stirage allocation facility  static definition stack discipline provided by the local variables of functions there is no heap or garbage collection (?)     Input / Output  C itself provides no input/output facilities  no READ, WRITE statement no built-in file access methods   input/output provided by explicitly-called functions   C supports only single-thread control flow (?)  tests, loops, grouping, subprograms no multiprogramming      ","permalink":"https://niiok.github.io/c/intro/","summary":"Introduction Writer prefer 1983 ANSI C (K\u0026amp;R 2nd).   C was born for UNIX\n C is machine independent C is simple and concise (even though program with it is complicated)    Creator\u0026rsquo;s words\n   C is a general-purpose programming language which features economy of expression, modern control flow and data structures, and a rich set of operators.\n    C wears well as one\u0026rsquo;s experience with it grows.","title":"Intro"},{"content":"  MFC is Microsoft Foundation Class.\n  composed with combination of Win32 api and class (object-oriented)\n  MFC is almost depricated by many alternatives like .net WPF and other crossplatform GUI libraries\n  declare field HWnd inside header file to create child windows\n you need to call Create() method of them to replace CreateWindow() of win32    since MFC works as OOP wrapper of win32, message dealing system how win32 do with CALLBACK function is replaced by MessageMap macro inside HWnd\n  SDI\n CWinApp CFrameWind CView CDocument    MDI\n  Dialog based\n  MessageMap\n do work of CALLBACK funtion on MFC composed with two macros (at top of source);  BEGIN_MESSAGE_MAP( CustumView, CView ) END_MESSAGE_MAP()   examples  OnCreate() : mapped with WM_CREATE (ON_WM_CREATE()) OnSize() : mapped with WM_SIZE (ON_WM_SIZE()) OnPaint() : mapped with WM_PAINT (ON_WM_PAINT()) OnClose() : mapped with WM_CLOSE (ON_WM_CLOSE()) ON_COMMAND( CHILD_ID, OnCustumFunction )  this is macro inside message map unlike default mapping like ON_WM_CREATE(), this macro has two parameters  CHILD_ID : UINT value (normally defined by macro) OnCustumFunction : void (*) (void) type function   calls OnCustumFunction() when control with CHILD_ID occur WM_COMMAND message     message processing class  almost messages occur in CView type object. so message will be sent in CView\u0026rsquo;s MessageMap. but if there\u0026rsquo;s no proper MessageMap in CView type object, it will be sent to CDocument type object\u0026rsquo;s MessageMap. if there\u0026rsquo;s no MessageMap, next is CFrameWnd. and next is CwinApp. CView -\u0026gt; CDocument -\u0026gt; CFrameWnd -\u0026gt; CWinApp\n     CWinApp\n InitInstance() : called when mfc program started Run() : loop function ExitInstance() : called when mfc progran ended    AfxMessageBox()\n1  void AfxMessageBox( _T(\u0026#34;text\u0026#34;) );    work as MessageBox of win32    ","permalink":"https://niiok.github.io/windows/mfc/","summary":"MFC is Microsoft Foundation Class.\n  composed with combination of Win32 api and class (object-oriented)\n  MFC is almost depricated by many alternatives like .net WPF and other crossplatform GUI libraries\n  declare field HWnd inside header file to create child windows\n you need to call Create() method of them to replace CreateWindow() of win32    since MFC works as OOP wrapper of win32, message dealing system how win32 do with CALLBACK function is replaced by MessageMap macro inside HWnd","title":"MFC"},{"content":" CObject  CCmdTarget  CWinThread  CWinApp   CDocumen CDocTemPlate  CSingleDocTemplace CMultiDocTemplatet   CWnd (Window Support)  CFrameWnd (Frame Windows)  CMDIChildWnd  (user MDI windows)   CMDIFrameWnd  (user MDI workspaces)   CMiniFrameWnd (user SDI windows) COleIPFrameWnd   CSplitterWnd CControlBar (Control Bars)  CDialogBar COleResizeBar CReBar CStatusBar CToolBar   CPropertySheet (Property Sheets) CDialog (Dialog Boxes)  CCommonDialog  CColorDialog CFileDialog CFindReplaceDialog CFontDialog COleDialog  COleBusyDialog COleChangeIconDialog COleChangeSourceDialog COleConvertDialog COleInsertDialog COleLinksDialog  COleUpdateDialog   COlePasteSpecialDialog COlePropertiesDialog   CPageSetupDialog CPrintDialog CPrintDialogEx   COlePropertyPage CPropertyPage (user dialog boxes) CDHtmlDialog  CMultiPageDHtmlDialog     CView (Views)  CCtrlView  CEditView CListView CRichEditView CTreeView   CScrollView  (user scroll views) CFormView  (user form views) CDaoRecordView CHtmlEditView CHtmlView COleDBRecordView CRecordView  (user record views)           (Controls)  CAnimateCtrl CComboBox CDateTimeCtrl CEdit CHeaderCtrl CHtmlEditCtrl CHotKeyCtrl CIPAdressCtrl CLinkCtrl CListBox CListCtrl CMonthCalCtrl COleControl CProgressCtrl CReBarCtrl CRichEditCtrl CScrollBar CSliderCtrl CSpinButtonCtrl CStatic CStatusBarCtrl CTabCtrl CToolBarCtrl CToolTipCtrl CTreeCtrl     CDC  CClientDC CMetaFileDC CPaintDC CWindowDC   CGdiObject  CBitMap CBrush CFont CPalette CPen CRgn   CFile  CMemFile  CShareFile   COleStreamFile  CMonikerFile  CAsyncMonikerFile  CDataPathProperty  CCachedDataPathProperty         CSocketFile CStdioFile  CInternetFile  CGopherFile CHttpFile       CRecentFileList (Arrays)  CArray (template) CByteArray CDWordArray CObArray CPtrArray CStringArray CUIntArray CWordArray (arrays of user types)   (Lists)  CList (template) CPtrList CObList CStringList (lists of user types)   (Maps)  CMap (template) CMapWordToPtr CMapPtrToWord CMapPtrToPtr CMapWordToOb CMapStringToPtr CMapStrngToOb CMapStringToString     CPoint CRect  composed with 4 integers first 2 are x and y of left top vertex last 2 are x and y of right bottom vertex -CSize -CString\n     Create()  almost same with CreateWindow()\u0026rsquo;s method version    ","permalink":"https://niiok.github.io/windows/mfc_class/","summary":"CObject  CCmdTarget  CWinThread  CWinApp   CDocumen CDocTemPlate  CSingleDocTemplace CMultiDocTemplatet   CWnd (Window Support)  CFrameWnd (Frame Windows)  CMDIChildWnd  (user MDI windows)   CMDIFrameWnd  (user MDI workspaces)   CMiniFrameWnd (user SDI windows) COleIPFrameWnd   CSplitterWnd CControlBar (Control Bars)  CDialogBar COleResizeBar CReBar CStatusBar CToolBar   CPropertySheet (Property Sheets) CDialog (Dialog Boxes)  CCommonDialog  CColorDialog CFileDialog CFindReplaceDialog CFontDialog COleDialog  COleBusyDialog COleChangeIconDialog COleChangeSourceDialog COleConvertDialog COleInsertDialog COleLinksDialog  COleUpdateDialog   COlePasteSpecialDialog COlePropertiesDialog   CPageSetupDialog CPrintDialog CPrintDialogEx   COlePropertyPage CPropertyPage (user dialog boxes) CDHtmlDialog  CMultiPageDHtmlDialog     CView (Views)  CCtrlView  CEditView CListView CRichEditView CTreeView   CScrollView  (user scroll views) CFormView  (user form views) CDaoRecordView CHtmlEditView CHtmlView COleDBRecordView CRecordView  (user record views)           (Controls)  CAnimateCtrl CComboBox CDateTimeCtrl CEdit CHeaderCtrl CHtmlEditCtrl CHotKeyCtrl CIPAdressCtrl CLinkCtrl CListBox CListCtrl CMonthCalCtrl COleControl CProgressCtrl CReBarCtrl CRichEditCtrl CScrollBar CSliderCtrl CSpinButtonCtrl CStatic CStatusBarCtrl CTabCtrl CToolBarCtrl CToolTipCtrl CTreeCtrl     CDC  CClientDC CMetaFileDC CPaintDC CWindowDC   CGdiObject  CBitMap CBrush CFont CPalette CPen CRgn   CFile  CMemFile  CShareFile   COleStreamFile  CMonikerFile  CAsyncMonikerFile  CDataPathProperty  CCachedDataPathProperty         CSocketFile CStdioFile  CInternetFile  CGopherFile CHttpFile       CRecentFileList (Arrays)  CArray (template) CByteArray CDWordArray CObArray CPtrArray CStringArray CUIntArray CWordArray (arrays of user types)   (Lists)  CList (template) CPtrList CObList CStringList (lists of user types)   (Maps)  CMap (template) CMapWordToPtr CMapPtrToWord CMapPtrToPtr CMapWordToOb CMapStringToPtr CMapStrngToOb CMapStringToString     CPoint CRect  composed with 4 integers first 2 are x and y of left top vertex last 2 are x and y of right bottom vertex -CSize -CString","title":"MFC classes"},{"content":"Function  Buffer  glClearBuffer  1  void glClearBufferfv (GLenum buffer, GLint drawBuffer, const GLfloat *value);    clear buffer of drawBuffer with value\n _drawBuffer_의 _buffer_를 _value_로 지운다. --  Shader \u0026amp; Program object manage  glCreateShader  1  GLuint glCreateShader (GLenum type);    create type of shader(structure that manage shader code compile and linking it) and return GLuint as identifier.\n  glShaderSource  1  void glShaderSource (GLuint shader, GLsizei count, const GLchar* const *string, const GLint *length);    will add more explains\n  glCompileShader  1  void glCompileShader (GLuint shader);    Compile shader indenfied shader.\n  glCreateProgram  1  GLuint glCreateProgram (void);    create a program object and return its identifier.\n  glAttachShader  1  void glAttachShader (GLuint program, GLuint shader);    attach shader to program\n  glLinkProgram  1  void glLinkProgram (GLuint program);    as its name\n  glDeleteShader  1  void glDeleteShader (GLuint shader);    as its name\n  glDeleteProgram  1  void glDeleteProgram (GLuint program);    as its name\n  Vertex Shader manage Vertex Array  glGenVertexArrays  1  void glGenVertexArrays (GLsizei n, GLuint *arrays);    Generate n number of VAO(Vertex Array Object)s in arrays. since this function access GLuint as array, it requires arrays' address as parameter.\n  glBindVertexArray  1  void glBindVertexArray (GLuint array);    bind array(VAO) to current context.\n ood  glDrawArrays  1  void glDrawArrays (GLenum mode, GLint first, GLsizei count);    send vertices to pipeline. started from first, count of vertices with premitive mode mode example: GL_POINTS, GL_LINES, GL_TRIANGLES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_PATCHES, \u0026hellip;\n  glVertexAttrib  1  void glVertexAttrib4fv(GLuint index, const GLfloat *v);    set 4fv of vertex attribute to layout(loaction = index). 4fv means 4 float vector(array)\n  Tessellation Shader manage  glPatchParameteri  1  void glPatchParameteri (GLenum pname, GLint value);    tname example: GL_PATCH_VETICES\n  Geometry Shader manage change point pixel size into _`size`_ ```C void glPolygonMode (GLenum face, GLenum mode); ``` ```C void glViewport (GLint x, GLint y, GLsizei width, GLsizei height); ``` ```C void glDepthRange (GLdouble nearVal, GLdouble farVal); ``` ```C glFrontFace() ``` Gets winding order and set _`dir`_ order primitive as front face of culling process. dir : GL_CW(clockwise), GL_CCW(counterclockwise) default front face when glFrontFace was never called is GL_CCW. ```C glEnable ``` cap : GL_CULL_FACE : enable culling ```C glCullFace() ``` choose which faces to cull. ex) GL_FRONT, GL_BACK, GL_FRONT_AND_BACK --  Shader Built-in variable   gl_Position   (out) represents transform of vertex\n  gl_VertexID   specify id used in vertex shader (in) Ex: glDrawArrays) started from first , count number of vertex\n   gl_InvocationID   (in) used fo 0-based index of gl_in, gl_out\n  gl_TessLevelInner gl_TessLevelOuter   (out) Tessellation factor variable array contain tessellation level\n   gl_TessCoord   (in)barycentric coodinate of vertex\n  1  EmitVertex()    make vertex with gl_Position of geometry shader\n 1  EndPrimitive()    automatically called when geometry shader end\n   gl_FragCoord   (in)coordinate of fragment to manipulate\n  General  gl_in gl_out   not simple variable, but array\n  floor  1  float floor (float f);   floor function in glsl. i.e. return integer part of f. trunc funtion is used in absolute value\u0026rsquo;s case.\n fract  1  float fract (float f);   return fractional part of f.\n mix  1  vec4 mix (vec4 A, vec4 B, float t);   linear interpolation. has sevelar verstions take different dimensional vectors or scalars as A and B, t shows iterpolating parameter represented by scalar or matching vector.\n layout   Vertex layout (location = 0) in vec4 variablename; //location used as attribute index\n  Tesselation Control layout (vertices = 3) out; //output control point(vertices) per patch\n  Tesselation Evaluation layout (triangles, equal_spacing, cw) in; //setting for tessellation mode\n  Geometry layout (triangles) in; layout (points, max_vertices = 3) out; //get input as triangle and divide them into points\n  Fragment\n  Compute layout (local_size_x = 32, local_size_y = 32) in; //local workgroup szie is 32*32\n   extension #extension GL_extension_feature_en : enable //enable feature both device support it or not #extension GL_extension_feature_re : required //if this extensio is not replaceable, use required for assertive code #if GL_extension_feature_en //extension's name will be defined with macro so you can manage code #else //alternative codes if extension doesn't supported #endif  Fixed Block  Pixel Operations scissor test =\u0026gt; stencil test =\u0026gt; depth test =\u0026gt;  Coordinate space   Model space (=object space) local origin following coordinate space\n  World space global origin following coordinate space\n  View space (=camera, =eye space) relative coordinate space to viewer\n  Clip space coordniate space after projection on homogeneous coordinate\n  Normalized device coordinate(NDC) space coordinate space after dividing clip space by w component\n  Window space window origin following coordinate space\n  Transform  View - Clip Transform can be performed by projection matrix : orthographic, perspective, etc\u0026hellip; occurs after Model - View Transform.  ================================================================\n ","permalink":"https://niiok.github.io/opengl/opengl_basic/","summary":"Function  Buffer  glClearBuffer  1  void glClearBufferfv (GLenum buffer, GLint drawBuffer, const GLfloat *value);    clear buffer of drawBuffer with value\n _drawBuffer_의 _buffer_를 _value_로 지운다. --  Shader \u0026amp; Program object manage  glCreateShader  1  GLuint glCreateShader (GLenum type);    create type of shader(structure that manage shader code compile and linking it) and return GLuint as identifier.\n  glShaderSource  1  void glShaderSource (GLuint shader, GLsizei count, const GLchar* const *string, const GLint *length);    will add more explains","title":"OpenGL basic"},{"content":"OpenGL Data type OpenGL provides Buffer and Texture as storage for more efficient data streaming. (modern graphics processors are designed with streaming processor.)\n  Buffer\n glBindBuffer() glBufferData() glBufferSubData() glClearBufferSubData() glCopyBufferSubData() glGenBuffers() glMapBuffer() \u0026lt;\u0026ndash; - glCreateBuffers \u0026ndash;\u0026gt;    Vertex Attribute\n glVertexAttribPointer() glEnableVertexAttribArray() glDisableVertexAttribArray() glGetAttribLocation()    Uniform\n Default Block   glUniform*() glUniformMatrix*()  Uniform Block   glGetUniformIndicies() glGetActiveUniforms() glGetUniformLocation()     Buffer   need name for identify handle\n  memory space allocated for buffer object is called data storage.\n  two method to put data in buffer are ; using command ; mapping with pointer\n  can bind into context\u0026rsquo;s buffer binding point with buffer\u0026rsquo;s name.\n  binding point can be refered as target in most cases. (but target may have multiple binging point)\n  buffer binding process\n   glGenBuffers -\u0026gt; glBindBuffer -\u0026gt; glBufferData\n  There\u0026rsquo;s many way to manipulate buffer object\u0026rsquo;s data  using data parameter of glBufferData() using glBufferSubData() using glMapBuffer()       glBindBuffer()  1  void glBindBuffer (GLenum target, GLuint buffer);    target enum list  GL_ARRAY_BUFFER\t: Vertex attributes GL_ATOMIC_COUNTER_BUFFER\t: Atomic counter storage GL_COPY_READ_BUFFER\t: Buffer copy source GL_COPY_WRITE_BUFFER\t: Buffer copy destination GL_DISPATCH_INDIRECT_BUFFER\t: Indirect compute dispatch commands GL_DRAW_INDIRECT_BUFFER\t: Indirect command arguments GL_ELEMENT_ARRAY_BUFFER\t: Vertex array indices GL_PIXEL_PACK_BUFFER\t: Pixel read target GL_PIXEL_UNPACK_BUFFER\t: Texture data source GL_QUERY_BUFFER\t: Query result buffer GL_SHADER_STORAGE_BUFFER\t: Read-write storage for shaders GL_TEXTURE_BUFFER\t: Texture data buffer GL_TRANSFORM_FEEDBACK_BUFFER\t: Transform feedback buffer GL_UNIFORM_BUFFER\t: Uniform block storage      glBufferData()  1  void glBufferData (GLenum target, GLsizeiptr size, const GLvoid * data, GLenum usage);   create \u0026lsquo;data store\u0026rsquo;(memory) for current buffer object of target.\n  target enum list\n GL_ARRAY_BUFFER GL_ELEMENT_ARRAY_BUFFER GL_PIXEL_PACK_BUFFER GL_PIXEL_UNPACK_BUFFER    usage enum list\n GL_STREAM_DRAW : modified once by application, accessed rarely, used for drawing and imaging. GL_STREAM_READ : modified once by GL reading, accessed rarely, used for returning data for queries of application. GL_STREAM_COPY : modified once by GL reading, accessed rarely, used for drawing and imaging. GL_STATIC_DRAW : modified once by GL application, accessed often, used for drawing and imaging. GL_STATIC_READ : modified once by GL reading, accessed often, used for returning data for queries of application. GL_STATIC_COPY : modified once by GL reading, accessed often, used for drawing and imaging. GL_DYNAMIC_DRAW : modified multiple time by GL application, accessed often, used for drawing and imaging. GL_DYNAMIC_READ : modified multiple time by GL reading, accessed often, used for returning data for queries of application. GL_DYNAMIC_COPY : modified multiple time by GL reading, accessed often, used for drawing and imaging.     size is size of data store. data is pointer indicating where data storage copy initial data from. can be setted as NULL and data store won\u0026rsquo;t be initalized.\n   glBufferSubData()  1  void glBufferSubData (GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid * data);    target enum list is same with glBindBuffer. offset is position inside buffer to start inserting data size is byte size of inserting data data is pointer for data to insert in buffer\n   glClearBufferSubData()  1  void glClearBufferSubData (GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void * data);     format enum list\n GL_RED\t: 1 channel GL_RG\t: 2 channel GL_RGB\t: 3 channel GL_RGBA\t: 4 channel    type basic types\n GL_BYTE\t: GLchar GL_UNSIGNED_BYTE\t: GLuchar GL_SHORT\t: GLshort GL_UNSIGNED_SHORT\t: GLushort GL_INT\t: GLint GL_UNSINGED_INT\t: GLuint GL_FLOAT\t: GLfloat GL_DOUBLE.\t: GLdouble     target is buffer to clear with constant value internalformat is specific format to convert offset is offset byte to start clear size is bytes to continue clear format and type are method to adjust data in data\n   glCopyBufferSubData()  1  vod glCopyBufferSubData (GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size);    this function use buffer binding points_readtarget, writetarget_. and this way of copying has unwanted sideeffects sometime. so GL_COPY_READ_BUFFER and GL_COPY_WRITE_BUFFER are provided for dedicated binding point.\n   glGenBuffers()  1  void glGenBuffers (GLsizei n, GLuint * buffers);    glGenBuffers generate n of buffers and insert their buffer names into GLuint array buffers.\n   glMapBuffer()  1  void* glMapBuffer (GLenum target, GLenum access);    access enum list  GL_READ_ONLY\t: returned pointer will be used for reading buffer object\u0026rsquo;s data GL_WRITE_ONLY\t: returned pointer will be used for writing buffer object\u0026rsquo;s data GL_READ_WRITE\t: returned pointer will be used for both reading and writing     map data store of target buffer object into client\u0026rsquo;s address space and return its void* pointer address. target enum list is same with glBindBuffer. using returned pointer address for GL function parameter is nonstandard. it may occur unexpected result. can unmap with glUnmapBuffer (_target_);.\n  alternative of glGenBuffers for modern openGL. --    Vertex attribute  glVertexAttribPointer()  1 2 3 4 5 6  void glVertexAttribPointer (GLuint index, GLint size = 0, GLenum type = GL_FLOAT, GLboolean normalized. GLsizei stride = 0, const GLvoid * pointer = 0 );    index is index of vertex attribute inside \u0026ldquo;layout (location = index)\u0026rdquo; to insert. size is number (1, 2, 3, 4) of components like \u0026lsquo;3 for vec3\u0026rsquo; or \u0026lsquo;4 for vec4\u0026rsquo;. type is data types like GL_FLOAT, GL_INT, GL_BYTE, etc. since float is standard type for opengl vector, they will be converted into float, and it\u0026rsquo;s reason for normalized is important. if normalized is GL_TRUE, that means datas' values need to be float with value between 0.0 to 1.0 for unsigned, -1.0 to 1.0 for signed. stride indicates offset gap size between first attribute and second attribute. If this value is 0, it will be sizeof(type) * size. pointer parameter seems like pointer, but it\u0026rsquo;s byte offset for where attribute starts inside of GL_ARRAY_BUFFER.\n   glEnableVertexAttribArray()  1  void glEnableVertexAttribArray (GLuint index);    glDisableVertexAttribArray()  1  void glDisableVertexAttribArray (GLuint index);    if vertex attrib array is disabled, vertex attributes will be modified with glVertexAttrib*() funcionts. if vertex attrib array is abled, vertex attributes will be binded with glVertexAttribPointer() funtion.\n   glGetAttribLocation()  1  GLint glGetAttribLocation (GLuint program, const GLchar * name);    if your put program that owning vertex shader in program and name of vertex attribute\u0026rsquo;s name(identifier) in name, it will return name\u0026rsquo;s location number. if there no attribute with name, name, it will return -1.\n    Uniform   While attributes contribute in per-vertex sahder values (like position of vertice), uniform contirbute in same values to several vertex shaders (like transform matrix).\n  Uniform can exist in all kind of shaders.\n  Uniform in shaders are always constant and cannot be assigned by shader.\n  uniform may disappear after compile if none of shader use that uniform.\n  variable names are case-sensitive.\n    Default block\n Default block uniforms are just like sending vertex attributes but use glUniform*() instead glVertexAttrib*(). glUniform*() 1 2 3 4 5 6 7 8 9  //functions below are sample glUniform*(). void glUniform1f (GLint location, GLfloat v0); //glUniform1~4f void glUniform2i (GLint location, GLint v0, GLint v1); //glUniform1~4i void glUniform4ui (GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); //glUniform1~4ui  //functions below are glUniform*v() that use pointer (i.e. array, vector) to store multiple uniform data. void glUniform1fv (GLint location, GLuint count, const GLfloat* value); //glUniform1~4fv void glUniform2iv (GLint location, GLuint count, const GLint* value); //glUniform1~4iv void glUniform4uiv (GLint location, GLuint count, const GLuint* value); //glUniform1~4uiv    put value or v* into uniform with layout(location = location). boolean can be sent by any type of funtion like how C works. count is length of value, array that contain arrays(i.e. vectors). value is pointer (not pointer-pointer). and that means you dont need to put parameter value into form of array[][], instead just put array\u0026rsquo;s name (pointer).\n  glUniformMatrix*() 1 2 3 4 5 6 7 8 9  //matrix that store single-precision floating values glUniformMatrix2fv (GLint location, GLuint count, GLboolean transpose, const GLfloat *m); glUniformMatrix3fv (GLint location, GLuint count, GLboolean transpose, const GLfloat *m); glUniformMatrix4fv (GLint location, GLuint count, GLboolean transpose, const GLfloat *m); //matrix that store double-precition floating values glUniformMatrix2dv (GLint location, GLuint count, GLboolean transpose, const GLdouble *m); glUniformMatrix3dv (GLint location, GLuint count, GLboolean transpose, const GLdouble *m); glUniformMatrix4dv (GLint location, GLuint count, GLboolean transpose, const GLdouble *m);    shader matrices only stores single and double precision floating-point variety. this function can store array of matrices by setting count into larger than 1. OpenGL\u0026rsquo;s matrix is column-major. if sending matrix is not column-major, set transpose into GL_TRUE. so, use transpose parameter in handy if you use another graphic library that uses row-major matrix.\n     Uniform block (buffer)\n stored in buffer with interface form (UBO) just like vertex buffer. UBO is manipulated with functions like glBufferData() or glMapBuffer(). two way to store data in buffer  standard : store data with just same order as members of uniform block. extensive and safe but not efficient for memory space usage. since standard layout is not default, you need to put layout (std140) before uniform block declaration. shared : opengl make proper structure itself. shared layout is default layout if there\u0026rsquo;s none specification. most efficient for performance but need resource to let OpenGL manage them and application can be more complicated. shaders and programs share layout of buffer once buffer layout is decided into shared layout.       standard layout  std140 or any standard layouts have certain offset boundary and field packing rule.  array or vector of GLSL types have boundary offset of N*sizeof(vector). (e.g. vector of 2 floats has 4*2 byte boundary offset.) but array or vector with 3, 4 elements have boundary offset of N*4 bytes. (I think it\u0026rsquo;s for keeping binaric integrity.) every arrays aligned( =packed) just like vec4 in size. i.e. every arrays without vec4 and N*4 matricies - element arrays won\u0026rsquo;t be packed tightly. so you need to keep in mind to bind application array with proper offsets. structure and structure array\u0026rsquo;s boundary offsets defined by its largest member. (ceiled into size of vec4.) all of these rules look complex, but this is the way how standard layout guarantee cross-platform layout. you can check more about this from ARB_uniform_buffer_obect extention\u0026rsquo;s specification.     shared layout  shared layout may be more efficient than standard layout. but many people think it\u0026rsquo;s not worth to invest that much effort on it. you need to search block members' size and location wih indices of them. you can get indices' by using glGetUniformIndices(). 1  void glGetUniformIndices (GLuint program, GLsizei uniformCount, const GLchar **uniformNames, GLuint *uniformIndices);    program : program that you will get uniform index from. uniformCount : number of uniform indices you want to get. uniformNames : array of GLchar array( =string) that contains uniforms' name you want to get index of. uniformIndices : this funtion will write indices of uniform you selected in this array.\n  after getting array contain indices, you can get location of uniform block elements by glGetActiveUniformsiv(). 1  void glGetActiveUniformsiv (GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params);    program : program that you will get uniformCount : number of strides or offsets you want to get uniformIndices : array of indices you want to use for getting stride or offset. pname : enum for data type that this function will get. params : result of this function will be stored at here.\n  pname enum list  GL_UNIFORM_TYPE : data type of uniform block members GL_UNIFORM_SIZE\t: array\u0026rsquo;s size of member regardless of which GL_UNIFORM_TYPE gives. 1 will be stored if indexed member is not array. GL_UNIFORM_NAME_LENGTH\t: length of uniform block member\u0026rsquo;s name (character array\u0026rsquo;s length) GL_UNIFORM_BLOCK_INDEX\t: index of uniform block that member is located. (it\u0026rsquo;s not index of uniform block member. it\u0026rsquo;s useless since parameter include them!) GL_UNIFORM_OFFSET\t: offset of uniform block member GL_UNIFORM_ARRAY_STRIDE\t: byte stride of uniform block member array. if indexed member is not array, 0 will be stored. GL_UNIFORM_MATRIX_STRIDE\t: byte stride between uniform block member matrix' column or row. if indexed member is not matrix, 0 will be stored. GL_UNIFORM_IS_ROW_MAJOR\t: 1 will be stored if indexed matrix is row-major. 0 will be stored if index matrix is column-major or even not matrix at all.     with offset and stride informations, application need to set data in proper location of buffer to send data for shared layout shader.  you can use stride and offset as parameter of buffer modification functions like glBufferSubData(). if you used glMapBuffer, application need to take care with inputting data inside buffer.         glGetUniformLocation()  1  GLint glGetUniformLocation (GLuint program, const GLchar * name);    Used for finding location of uniform inside program. if you put program that owning vertex shader in program and name of uniform\u0026rsquo;s name(identifier) in name, it will return name\u0026rsquo;s location number. if there no attribute with name, name, it will return -1.\n  put _`value`_ or _`v*`_ into uniform with layout(location = _`location`_).  boolean can be sent by any type of funtion like how C works.  _`count`_ is length of _`value`_, array that contain arrays(i.e. vectors).  value is pointer (not pointer-pointer). and that means you dont need to put parameter _`value`_ into form of array[][], instead just put array's name (pointer).   glUniformMatrix*()  1 2 3 4 5 6 7 8 9  //matrix that store single-precision floating values glUniformMatrix2fv (GLint location, GLuint count, GLboolean transpose, const GLfloat *m); glUniformMatrix3fv (GLint location, GLuint count, GLboolean transpose, const GLfloat *m); glUniformMatrix4fv (GLint location, GLuint count, GLboolean transpose, const GLfloat *m); //matrix that store double-precition floating values glUniformMatrix2dv (GLint location, GLuint count, GLboolean transpose, const GLdouble *m); glUniformMatrix3dv (GLint location, GLuint count, GLboolean transpose, const GLdouble *m); glUniformMatrix4dv (GLint location, GLuint count, GLboolean transpose, const GLdouble *m);    shader matrices only stores single and double precision floating-point variety. this function can store array of matrices by setting count into larger than 1. OpenGL\u0026rsquo;s matrix is column-major. if sending matrix is not column-major, set transpose into GL_TRUE. so, use transpose parameter in handy if you use another graphic library that uses row-major matrix.\n \u0026ndash;\u0026gt;\nTexture ","permalink":"https://niiok.github.io/opengl/opengl_data/","summary":"OpenGL Data type OpenGL provides Buffer and Texture as storage for more efficient data streaming. (modern graphics processors are designed with streaming processor.)\n  Buffer\n glBindBuffer() glBufferData() glBufferSubData() glClearBufferSubData() glCopyBufferSubData() glGenBuffers() glMapBuffer() \u0026lt;\u0026ndash; - glCreateBuffers \u0026ndash;\u0026gt;    Vertex Attribute\n glVertexAttribPointer() glEnableVertexAttribArray() glDisableVertexAttribArray() glGetAttribLocation()    Uniform\n Default Block   glUniform*() glUniformMatrix*()  Uniform Block   glGetUniformIndicies() glGetActiveUniforms() glGetUniformLocation()     Buffer   need name for identify handle","title":"OpenGL data"},{"content":" Intro How Chapter 1 works?  Init SDL with SDL_Init(). Create window with SDL_CreateWindow(). Get surface with SDL_GetWindowSurface().  do something with surface. (like SDL_FillRect()).   Update surface with SDL_UpdateWindowSurface().  you can delay loop( for window lasting) with SDL_Delay().   If you done all your jobs with SDL, Destroy window with SDL_DestroyWindow(). Don\u0026rsquo;t forget calling SDL_Quit() for terminating all jobs!  SDL.h  main header file for sdl. includes video, (will be updated) when you setup SDL.h and other libraries, check  include (-I) library (-L) link (-l) dll (windows)    main  main function type is fixed for cross-platform. 1  int main( int argc, char* args[] );      Function SDL_Init() 1  int SDL_Init( Uint32 flags );    param  flags : subsystem initialization flags   return  0 on success negative integer as error code on failure     you need to call this function to use SDL functions. input flags you\u0026rsquo;ll use as parameter.\n SDL_GetError() 1  const char* SDL_GetError( void );    param  void   return  character array on message with information about error empty array on no error happen     this function will return character array that represents latest error.\n SDL_CreateWindow() 1  SDL_Window* SDL_CreateWindow( const char* title, int x, int y, int w, int h, Uint32 flags );    param  title : the title of the window. un UTF-8 encoding x : the x position of the window. SDL_WINDOWPOS_CENTERED or SDL_WINDOWPOS_UNDEFINED y : the y position of the window. SDL_WINDOWPOS_CENTERED or SDL_WINDOWPOS_UNDEFINED w : the width of the window. in screen coordinates h : the height of the window. in screen coordinates flags : 0, or one or more SDL_WindowFlags OR\u0026rsquo;d together (?)   return  window object\u0026rsquo;s address on success NULL on failure     every SDL_Video works on SDL_Window object. this function will create and return abstract window that compatible with OS.\n SDL_GetWindowSurface() 1  SDL_Surface* SDL_GetWindowSurface( SDL_Window* window );    param  window : the window to query   return  surface object that asociated with the window\u0026rsquo;s address on success NULL on failure     after SDL_Window created, you can read and write SDL_Surface from/to SDL_Window. this function will get address of SDL_Surface that asociated with window.\n SDL_FillRect() 1  int SDL_FillRect( SDL_Surface* dst, const SDL_Rect* rect, Uint32 color );    param  dst : the SDL_Surface structure that is the drawing target rect : the SDL_Rect structure representing the rectangle to fill, or NULL to fill the entire surface color : the color to fill with (SDL_MapRGB() or SDL_MapRGBA())   return  0 on success negative integer as error code on failure     this function is one kind of draw function. SDL_Rect for area, SDL_Surface as target, and SDL_MapRGB(A) will choose color.\n SDL_MapRGB() 1  Uint32 SDL_MapRGB( const SDL_PixelFormat* format, Uint8 r, Uint8 g, Uint8 b );    param  format : an SDL_PixelFormat structure describing the pixel format r : the red component of the pixel in the range 0~255 g : the green component of the pixel in the range 0~255 b : the blue component of the pixel range 0~255   return  pixel value on everytime     simple but cross-platform color returning function.\n SDL_UpdateWindowSurface() 1  int SDL_UpdateWindowSurface( SDL_Window* window );    param  window : the window to update   return  0 on success negative integer as error code on failure     SDL_Window object will reload SDL_Surface asociated with it without changing it.\n SDL_Delay() 1  void SDL_Delay( Uint32 ms );    param  ms : the number of milliseconds to delay   return  void     simple cross-platform sleep function.\n SDL_DestroyWindow() 1  void SDL_DestroyWindow( SDL_Window* window );    param  window : the window to destroy   return  void     call this function when you\u0026rsquo;re done with that SDL_Window object.\n SDL_Quit() 1  void SDL_Quit( void );    param  void   return  void     this function called after all SDL jobs are done. SDL recommend to call this function essentially at end of program.\n  Struct SDL_Window SDL_Surface  Term SDL_Init()  Uint32 flags  SDL_INIT_TIMER: timer subsystem SDL_INIT_AUDIO: audio subsystem SDL_INIT_VIDEO: video subsystem; automatically initializes the events subsystem SDL_INIT_JOYSTICK: joystick subsystem; automatically initializes the events subsystem SDL_INIT_HAPTIC: haptic (force feedback) subsystem SDL_INIT_GAMECONTROLLER: controller subsystem; automatically initializes the joystick subsystem SDL_INIT_EVENTS: events subsystem SDL_INIT_EVERYTHING: all of the above subsystems SDL_INIT_NOPARACHUTE: compatibility; this flag is ignored    SDL_CreateWindow()  int x,y  SDL_WINDOWPOS_CENTERED SDL_WINDOWPOS_UNDEFINED   Uint32 flag  SDL_WINDOW_SHOWN : shown window SDL_WINDOW_FULLSCREEN: fullscreen window SDL_WINDOW_FULLSCREEN_DESKTOP: fullscreen window at desktop resolution SDL_WINDOW_OPENGL: window usable with an OpenGL context SDL_WINDOW_VULKAN: window usable with a Vulkan instance SDL_WINDOW_METAL: window usable with a Metal instance SDL_WINDOW_HIDDEN: window is not visible SDL_WINDOW_BORDERLESS: no window decoration SDL_WINDOW_RESIZABLE: window can be resized SDL_WINDOW_MINIMIZED: window is minimized SDL_WINDOW_MAXIMIZED: window is maximized SDL_WINDOW_INPUT_GRABBED: window has grabbed input focus SDL_WINDOW_ALLOW_HIGHDPI: window should be created in high-DPI mode if supported (\u0026gt;= SDL 2.0.1)    ","permalink":"https://niiok.github.io/sdl/lazyfoo1/","summary":"Intro How Chapter 1 works?  Init SDL with SDL_Init(). Create window with SDL_CreateWindow(). Get surface with SDL_GetWindowSurface().  do something with surface. (like SDL_FillRect()).   Update surface with SDL_UpdateWindowSurface().  you can delay loop( for window lasting) with SDL_Delay().   If you done all your jobs with SDL, Destroy window with SDL_DestroyWindow(). Don\u0026rsquo;t forget calling SDL_Quit() for terminating all jobs!  SDL.h  main header file for sdl.","title":"SDL Chapter 1"},{"content":" Intro How Chapter 2 works?  Init()  SDL_Init() SDL_CreateWindow() SDL_GetWindowSurface()   loadMedia()  SDL_LoadBMP()   copy image(Blit) into surface with SDL_BlitSurface(). update window with SDL_UpdateWindowSurface() to refresh and show what we\u0026rsquo;ve done.  you can delay loop( for window lasting) with SDL_Delay().   close()  SDL_FreeSurface() SDL_DestroyWindow() SDL_Quit()     Function SDL_LoadBMP() 1  SDL_Surface* SDL_LoadBMP( const char* file );    param  file : the file containing a BMP image   return  surface that contain BMP on success NULL on failure     Gets SDL_Surface object from BMP file and returns its address.\n SDL_FreeSurface() 1  void SDL_FreeSurface( SDL_Surface* surface );    param  surface : the SDL_Surface to free   return is void   free surface object on memory.\n SDL_BlitSurface() 1  int SDL_BlitSurface( SDL_Surface* src, const SDL_Rect* srcrect, SDL_Surface* dst, SDL_Rect* dstrect );    param  src : the SDL_Surface structure to be copied from srcrect : the SDL_Rect structure representing the rectangle to be copied, or NULL to copy the entire surface dst : the SDL_Surface structure that is the blit target dstrect : the SDL_Rect structure representing the rectangle that is copied into   return  0 on blit success negative integer as error code on failure     Blit image into surface\u0026rsquo;s rect area or entire surface.\n  Struct  nothing new   Term  nothing new  ","permalink":"https://niiok.github.io/sdl/lazyfoo2/","summary":"Intro How Chapter 2 works?  Init()  SDL_Init() SDL_CreateWindow() SDL_GetWindowSurface()   loadMedia()  SDL_LoadBMP()   copy image(Blit) into surface with SDL_BlitSurface(). update window with SDL_UpdateWindowSurface() to refresh and show what we\u0026rsquo;ve done.  you can delay loop( for window lasting) with SDL_Delay().   close()  SDL_FreeSurface() SDL_DestroyWindow() SDL_Quit()     Function SDL_LoadBMP() 1  SDL_Surface* SDL_LoadBMP( const char* file );    param  file : the file containing a BMP image   return  surface that contain BMP on success NULL on failure     Gets SDL_Surface object from BMP file and returns its address.","title":"SDL Chapter 2"},{"content":" Intro How Chapter 3 works?  Init()  SDL_Init() SDL_CreateWindow() SDL_GetWindowSurface()   loadMedia()  SDL_LoadBMP()   start loop untill variable quit is true.  start loop that calls SDL_PollEvent() untill it returns 0.  if SDL_Event.type is SDL_QUIT, quit is true( which means first loop will end). copy screen(Blit) with SDL_BlitSurface(). update window with SDL_UpdateWindowSurface() to refresh and show what we\u0026rsquo;ve done.     close()  SDL_FreeSurface() SDL_DestroyWindow() SDL_Quit()     Function SDL_PollEvent() 1  int SDL_PollEvent( SDL_Event* event );    param  event : the SDL_Event structure to be filled with the next event from the queue, or NULL   return  1 if queue contains any event inside 0 if there\u0026rsquo;s no event in queue     when this function called, event at head will be removed from queue and stored to event. (return value 1 shows this works happend) (NULL inside queue won\u0026rsquo;t works like this) this function implicitly contains SDL_PumpEvent().\n  Struct SDL_Event  general cross-platform event struct contains event data\n  Term SDL_Event..type  SDL_QUIT  ","permalink":"https://niiok.github.io/sdl/lazyfoo3/","summary":"Intro How Chapter 3 works?  Init()  SDL_Init() SDL_CreateWindow() SDL_GetWindowSurface()   loadMedia()  SDL_LoadBMP()   start loop untill variable quit is true.  start loop that calls SDL_PollEvent() untill it returns 0.  if SDL_Event.type is SDL_QUIT, quit is true( which means first loop will end). copy screen(Blit) with SDL_BlitSurface(). update window with SDL_UpdateWindowSurface() to refresh and show what we\u0026rsquo;ve done.     close()  SDL_FreeSurface() SDL_DestroyWindow() SDL_Quit()     Function SDL_PollEvent() 1  int SDL_PollEvent( SDL_Event* event );    param  event : the SDL_Event structure to be filled with the next event from the queue, or NULL   return  1 if queue contains any event inside 0 if there\u0026rsquo;s no event in queue     when this function called, event at head will be removed from queue and stored to event.","title":"SDL Chapter 3"},{"content":" Intro How Chapter 4 works?  init()  SDL_Init() SDL_CreateWindow() SDL_GetWindowSurface()   loadMedia()  put surfaces in SDL_Surface* array( is global variable) with SDL_LoadBMP().   start loop untill variable quit is true.  start loop that calls SDL_PollEvent() untill it returns 0.  if SDL_Event.type is SDL_QUIT, quit is true( which means first loop will end).  else if SDL_Event.type is SDL_KEYDOWN, choose mapped sruface to key inside SDL_Surface* array( is global variable).   copy screen(Blit) with SDL_BlitSurface() from chosen surface to screen surface. update window with SDL_UpdateWindowSurface() to refresh and show what we\u0026rsquo;ve done.     close()  free surfacees in SDL_Surface* array( is global varable) with SDL_FreeSurface(). SDL_DestroyWindow() SDL_Quit()     Function  nothing new   Struct  nothing new   Term (enum(not official))KeyPressSurfaces  KEY_PRESS_SURFACE_DEFAULT KEY_PRESS_SURFACE_UP KEY_PRESS_SURFACE_DOWN KEY_PRESS_SURFACE_LEFT KEY_PRESS_SURFACE_RIGHT KEY_PRESS_SURFACE_TOTAL   these enum will have global SDL_Surface* array for having mapped surface.\n SDL_Event.type  SDL_KEYDOWN  SDL_Event.key.keysym.sym  SDLK_UP SDLK_DOWN SDLK_LEFT SDLK_RIGHT  ","permalink":"https://niiok.github.io/sdl/lazyfoo4/","summary":"Intro How Chapter 4 works?  init()  SDL_Init() SDL_CreateWindow() SDL_GetWindowSurface()   loadMedia()  put surfaces in SDL_Surface* array( is global variable) with SDL_LoadBMP().   start loop untill variable quit is true.  start loop that calls SDL_PollEvent() untill it returns 0.  if SDL_Event.type is SDL_QUIT, quit is true( which means first loop will end).  else if SDL_Event.type is SDL_KEYDOWN, choose mapped sruface to key inside SDL_Surface* array( is global variable).","title":"SDL Chapter 4"},{"content":" Intro How Chapter 5 works?  init()  SDL_Init() SDL_CreateWindow() SDL_GetWindowSurface()   loadMedia()  loadSurface()  load BMP file on intermediate surface with SDL_LoadBMP(). optimize loaded intermediate surface into optimized surface with SDL_ConvertSurface().  free memory of intermediate surface with SDL_FreeSurface().       start loop untill variable quit is true.  start loop that calls SDL_PollEvent() untill it returns 0.  if SDL_Event.type is SDL_QUIT, quit is true( which means first loop will end). copy screen(Blit) scaled one with SDL_BlitScaled(). update window with SDL_UpdateWindowSurface() to refresh and show what we\u0026rsquo;ve done.     close()  SDL_FreeSurface() SDL_DestroyWindow() SDL_Quit()     Function SDL_ConvertSurface() 1  SDL_Surface* SDL_ConvertSurface( SDL_Surface* src, const SDL_PixelFormat* fmt, Uint32 flags );    param  src : the existing SDL_Surface structure to convert fmt : the SDL_PixelFormat structure that the new surface is optimized for flags : the flags are unused and should be set to 0; this is a leftover from SDL 1.2\u0026rsquo;s API   return  new surface on success NULL on failure     get surface src and convert it into specific format that fmt indicating.\n SDL_BlitScaled() 1  int SDL_BlitScaled( SDL_Surface* src, const SDL_Rect* srcrect, SDL_Surface* dst, SDL_Rect* dstrect );    param  src : the SDL_Surface structure to be copied from srcrect : the SDL_Rect structure representing the rectangle to be copied, or NULL to copy entire surface dst : the SDL_Surface structure that is the blit target dstrect : the SDL_Rect structure representing the rectangle that is copied into, or NULL to copy into the entire surface   return  0 on success negative integer as error code on failure     Simiral with SDL_BlitSurface() but blit scaled surface. this function call SDL_LowerBlitScaled() internally.\n  Struct SDL_PixelFormat  Term  nothing new  ","permalink":"https://niiok.github.io/sdl/lazyfoo5/","summary":"Intro How Chapter 5 works?  init()  SDL_Init() SDL_CreateWindow() SDL_GetWindowSurface()   loadMedia()  loadSurface()  load BMP file on intermediate surface with SDL_LoadBMP(). optimize loaded intermediate surface into optimized surface with SDL_ConvertSurface().  free memory of intermediate surface with SDL_FreeSurface().       start loop untill variable quit is true.  start loop that calls SDL_PollEvent() untill it returns 0.  if SDL_Event.type is SDL_QUIT, quit is true( which means first loop will end).","title":"SDL Chapter 5"},{"content":" Intro How Chapter 6 works?  init()  SDL_Init() SDL_CreateWindow() IMG_Init() SDL_GetWindowSurface()   loadMedia()  loadSurface()  load PNG file on intermediate surface with IMG_Load(). optimize loaded intermediate surface into optimized surface with SDL_ConvertSurface().  free memory of intermediate surface with SDL_FreeSurface().       start loop untill variable quit is true.  start loop that calls SDL_PollEvent() untill it returns 0.  if SDL_Event.type is SDL_QUIT, quit is true( which means first loop will end). copy screen(Blit) with SDL_BlitSurface() from chosen PNG surface to screen surface. update window with SDL_UpdateWindowSurface() to refresh and show what we\u0026rsquo;ve done.     close()  SDL_FreeSurface() SDL_DestroyWindow() IMG_Quit() SDL_Quit()    SDL_image.h  SDL_image is used in this chapter if you\u0026rsquo;re running on Windows, you need to place dll file inside proper system directory (like Windows/System32)  if you have dll error, use where \u0026lt;dll_name.dll\u0026gt; command to find error-able dll\u0026rsquo;s location   writer is using IMG_2.0.4 version on SDL_2.0.9 version   Function IMG_Init() 1  int IMG_Init( int flags );    param  flsgs : bit flag indicates which image format to use while program   return  flags that loaded successfully on both entire, partial success 0 on failure     IMG_isJPG(), IMG_isPNG(), IMG_isTIF() doesn\u0026rsquo;t requires its initialization. you can check currently loaded system with calliing this function with 0.\n IMG_GetError() 1  char* IMG_GetError( void );    param  void   return  char array with recent error information on error empty array on no error happen     IMG version of SDL_GetError()\n IMG_Load() 1  SLD_Surface* IMG_Load( const char* file );    param  file : image file name string (char array/pointer)   return  image-loaded surface\u0026rsquo;s address on success NULL on error     this function calls IMG_LoadTyped_RW() inside logic. since this function returns surface, call SDL_FreeSurface() after use of this surface.\n IMG_Quit() 1  void IMG_Quit( void );    param  void   return  void     this function called after all IMG jobs are done. SDL recommend to call this function essentially at end of program if you used IMG subsystem.\n  Struct  nothing new   Term IMG_Init()  IMG_INIT_PNG IMG_INIT_JPG IMG_INIT_TIF IMG_INIT_*  ","permalink":"https://niiok.github.io/sdl/lazyfoo6/","summary":"Intro How Chapter 6 works?  init()  SDL_Init() SDL_CreateWindow() IMG_Init() SDL_GetWindowSurface()   loadMedia()  loadSurface()  load PNG file on intermediate surface with IMG_Load(). optimize loaded intermediate surface into optimized surface with SDL_ConvertSurface().  free memory of intermediate surface with SDL_FreeSurface().       start loop untill variable quit is true.  start loop that calls SDL_PollEvent() untill it returns 0.  if SDL_Event.type is SDL_QUIT, quit is true( which means first loop will end).","title":"SDL Chapter 6"},{"content":"This document is not done. On Going!!  Intro How Chapter 7 works?  init()  SDL_Init() SDL_SetHint() SDL_CreateWindow() SDL_CreateRenderer() SDL_SetRenderDrawColor() IMG_Init()   loadMedia()  loadTexture()  load PNG file on intermediate surface with IMG_Load(). create texture from loaded surface with SDL_CreateTextureFromSurface().  free memory of intermediate surface with SDL_FreeSurface().       start loop untill variable quit is true.  start loop that calls SDL_PollEvent() untill it returns 0.  if SDL_Event.type is SDL_QUIT, quit is true( which means first loop will end). clear screen(render) with SDL_RenderClear(). render texture(copy) on screen with SDL_RenderCopy(). update screen(of window) with SDL_RenderPresent() to refresh and show what we\u0026rsquo;ve done.     close()  SDL_DestroyTexture() SDL_DestroyRenderer() SDL_DestroyWindow() IMG_Quit() SDL_Quit()     now we are not using screen surface as our primary canvas anymore; instead renderer!  loadSueface() -\u0026gt; loadTexture() SDL_GetWindowSurface() is gone from init()  instead, SDL_SetHint(), SDL_CreateRenderer() and SDL_SetRenderDrawColor() are required   SDL_BlitSurface() is replaced into SDL_RenderClear() and SDL_RenderCopy() SDL_UpdateWindowSurface() is replaced into SDL_RenderPresent() SDL_FreeSurface() is gone from close()  instead, SDL_DestroyTexture() and SDL_DestroyRenderer() are required       Function SDL_SetHint() 1     param  `` :   return  **** on      SDL_CreateRenderer() 1     param  `` :   return  **** on      SDL_SetRenderDrawColor() 1     param  `` :   return  **** on      SDL_CreateTextureFromSurface() 1     param  `` :   return  **** on      SDL_RenderClear() 1     param  `` :   return  **** on      SDL_RenderCopy() 1     param  `` :   return  **** on      SDL_RenderPresent() 1     param  `` :   return  **** on      SDL_DestroyTexture() 1     param  `` :   return  **** on      SDL_DestroyRender() 1     param  `` :   return  **** on       Struct SDL_Renderer SDL_Texture  Term SDL_SetHint()  SDL_HINT_RENDER_SCALE_QUALITY  SDL_CreateRender()  SDL_RENDERER_ACCELERATED  ","permalink":"https://niiok.github.io/sdl/lazyfoo7/","summary":"This document is not done. On Going!!  Intro How Chapter 7 works?  init()  SDL_Init() SDL_SetHint() SDL_CreateWindow() SDL_CreateRenderer() SDL_SetRenderDrawColor() IMG_Init()   loadMedia()  loadTexture()  load PNG file on intermediate surface with IMG_Load(). create texture from loaded surface with SDL_CreateTextureFromSurface().  free memory of intermediate surface with SDL_FreeSurface().       start loop untill variable quit is true.  start loop that calls SDL_PollEvent() untill it returns 0.","title":"SDL Chapter 7"},{"content":"  purpose (to find-out)\n phenomenon (group characteristics) reason-result (relationship of factotrs) economic, social tendencies(, rules)  used for predicting future, and helping decision      how\n survey experiment observation    terms\n unit  person state food \u0026hellip;   case (record) variable    level of measurement (scale of measure)\n nominal scale : identifying use ordinal scale : serial ordering use interval scale : scoring use ratio scale : ratio use    data\n value\u0026rsquo;s level  qualitaive value quantitative value   value\u0026rsquo;s quantity  single-meaning value multi-meaning values      data, information repository\n korea  kostat kosis korea-index micro data service statstic-geographic information economic information   global  StRD DASL UCI data ksdc usa statistics      center tendency\n mean 1  mean(data)    trimmed mean 1  mean(data, trim=0.10)    median 1  median(data)    mode 1  mode(data)       dispersion\n1  summary(data)    variance     standard deviation 1  sd(data)    range     coefficient of variation     quartile deviation  interquartile range : Q3 - Q1  1 2  IQR(data) quantile(data, probs=c(0.25, 0.5, 0.75)) //it\u0026#39;s quaNtile, not quaRtile       continuous data graph\n histogram 1 2  a = rnorm(200) hist(a, col=\u0026#34;RED\u0026#34;)    stem-and-leaf 1 2  stem(data) stem(data, scale=2)    box plot 1  boxplot(data)    five-number-summary -adjacent value      web tool\n statpages inteructivate    ","permalink":"https://niiok.github.io/statistics/basic/","summary":"purpose (to find-out)\n phenomenon (group characteristics) reason-result (relationship of factotrs) economic, social tendencies(, rules)  used for predicting future, and helping decision      how\n survey experiment observation    terms\n unit  person state food \u0026hellip;   case (record) variable    level of measurement (scale of measure)\n nominal scale : identifying use ordinal scale : serial ordering use interval scale : scoring use ratio scale : ratio use    data","title":"Statistics basic"},{"content":"Unreal project If you want to study the API on your own; You should use that API as a user until you get used to it and read the header files. In every unreal code, they include \u0026ldquo;CoreMinimal.h\u0026rdquo; or \u0026ldquo;EngineMinimal.h\u0026rdquo; and those header files will be key to start studying.\nProject hierarchy   Config : project setting values. NEEDED-do not remove\n  Content : asset storage. NEEDED-do not remove\n  Intermediate : intermediate files. Recovered after remove\n  Saved : save files, screenshots and etc. Not recovered after remove\n  Binaries (C++) : binary files created after compile. Recovered after remove\n  Source (C++) : source files. NEEDED-do not remove If your project got something wrong and doesn\u0026rsquo;t work, remove unnecessary files(files in .gitignore) and execute .uproject file. If your project isn\u0026rsquo;t getting better and it\u0026rsquo;s clear UnreealEngine is preserving integrity, import proper Config files from new project to current project\u0026rsquo;s Config folder. (you need to change project name of files to adjust config.)\n  Type name prefix  A\t: classes inherited AActor; Actors U\t: classes inherited UObject; non-actor unreal objects S\t: classes inherited SWidget; Widgets E\t: Enum I\t: Interface T\t: Template F\t: Others b\t: boolean variables; not class, only variable  Type name and variable name are noun. Funtion name and method name are verb that describe their effct or return value(if it doesnt have effect.)\nUObject every classes in UE4 derived from UObject. Subclasses that not inherited from AActor generally called as UObject in documents.\nActor Actors are objects in world that consist game. Every actor is derived from AActor.\nComponent Components are subobject(not subclass) of Actors that endow functions with Actor. Every component is derived from UActorComponent.\nActor ├── Input ├── Movement │ ├── NavMovement │ │ ├── PawnMovement │ │ │ ├── CharacterMovement │ │ │ └── ... │ │ └── ... │ └── ... ├── Scene │ ├── Camera │ ├── SpringArm │ ├── Primitive │ │ ├── Mesh │ │ │ ├── Widget │ │ │ ├── StaticMesh │ │ │ │ └── ... │ │ │ ├── SkinnedMesh │ │ │ │ ├── SkeletalMesh │ │ │ │ │ └── ... │ │ │ │ └── ... │ │ │ └── ... │ │ ├── Shape │ │ │ ├── Capsule │ │ │ └── ... │ │ └── ... │ └── ... └── ...  ","permalink":"https://niiok.github.io/unreal/basic/","summary":"Unreal project If you want to study the API on your own; You should use that API as a user until you get used to it and read the header files. In every unreal code, they include \u0026ldquo;CoreMinimal.h\u0026rdquo; or \u0026ldquo;EngineMinimal.h\u0026rdquo; and those header files will be key to start studying.\nProject hierarchy   Config : project setting values. NEEDED-do not remove\n  Content : asset storage. NEEDED-do not remove","title":"Unreal basic"},{"content":" file extentions  .sln : solution file .suo : options of solution file .vcxproj : project file .sdf : compact SQL SERVER DATABASE that support browsing and navigation .vcsproj.filters : filter file that indicates file location of solution .vcxproj.user : lower-version-to-higher-version migration user file .ncb : symbol cache before compile .ilk : intermediate link data .aps : MFS resource cache .def : module definition file (serves linking informations to linker) .ipch folder : intellisence cache Debug folder : debug files    ","permalink":"https://niiok.github.io/windows/visual_studio/","summary":"file extentions  .sln : solution file .suo : options of solution file .vcxproj : project file .sdf : compact SQL SERVER DATABASE that support browsing and navigation .vcsproj.filters : filter file that indicates file location of solution .vcxproj.user : lower-version-to-higher-version migration user file .ncb : symbol cache before compile .ilk : intermediate link data .aps : MFS resource cache .def : module definition file (serves linking informations to linker) .","title":"Visual studio"},{"content":"  event driven\n when events happen, they stored into message form message stored into system queue OS was checking for system queue OS send message to aplication\u0026rsquo;s thread message queue application was checking for thread message queue (GetMessage) application calls event-matching callback function (TranslateMessage, DispatchMessage)    creating window\n declare WNDCLASS object declare proper LRESULT CALLBACK (*callback_function) (HWND, UINT, WPARAM, LPARAM) change fields(properties) inside WNDCLASS object  you need to set ipfnWndProc into callback_function as window processor you need to set lpszClassName into LPCSTR type string as window class name   declare WNDCLASS object with RegisterClass() Create window with CreateWindow()  you need to call ShowWindow() if window is invisible      window programming\n SDK (Software Development Kit) : low level programming with winAPI MFC (Microsoft Foundation Class) : useful library constructed by SDK RAD (Rapid Application Development) : faster and easier than MFC    handle\n index, object, instance, name, pointer, address 32bit integer start with h~ HWND, HPEN, HBRUSH, HDC    prefix\n h~ : handle n~ : (?) l~ : unicode (long)    data type\n BOOL BYTE : 8 bit unsigned DWORD : 32 bit unsigned LONG : 32 bit signed (same with long) LONGLONG : 64 bit unsigned FLOAT : float LPARAM : same with LONG but used for message parameter (32 bit) LPSTR : editable string. char * type pointer. end with NULL LPCSTR : uneditable string. const char * type pointer . end with NULL (const LPSTR) LPTSTR : editable unicode string. TCHAR * type pointer. end with NULL LPCTSTR : uneditable unicode string. const TCHAR * type pointer. end with NULL (const LPTSTR) TCHAR : unicode (window character) UNIT : 32 bit unsigned WORD : 16 bit unsigned WPARAM : same with UINT but used for message parameter (16 bit) COLORREF : composition of R, G, B (32 bit integer) POSITION : pointer for list attribute HWND : handle. 32 bit, same with HPEN, HHBRUSH, HDC    OutputDebugString()\n1  void OutputDebugString( LPCTSTR );    print debug messages while debugging window program\n      tbu\n  WinMain()\n1  int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdParam, int nCmdShow);    main() of Window programming (entry point)\n  hInstance : current instance of application hPrevInstance : deplicated. (used on 32-bit Windows) lpCmdLine : pointer for cmd parameters nCmdShow : choose how window will be seen on screen (NULL for default)   make window class. register window class. create window. show window. do get-message loop. return (end) program if loop is ended.\n      WNDCLASS\n1 2 3 4 5 6 7 8 9 10 11 12 13  typedef struct tagWNDCLASS { UINT\tstyle; WNDPROC\tipfnWndProc; int\tcbClsExtra; int\tcbWndExtra; HINSTANCE\thInstance; HICON\thIcon; HCURSOR\thCursor; HBRUSH\thbrBackground; LPCSTR\tlpszMenuName; LPCSTR\tlpszClassName; } WNDCLASS;    make window class with meta-class\n  lpfnWndProc : ESSENTIAL. window processor (callback funtion to bind) lpszClassName : ESSENTIAL. window class cbClsExtra, cdWndExtra : extra class memory, extra window memory (?) hInstance : current application instance handle (use already-made instance handle) hIcon, hCursor : handle for Icon and Cursor (use LoadCursor(), LoadIcon()) hbrBackground : brush for background (use GetStockObject()) lpszMenuName : (?) style : what can user change with window (?)    RegisterClass()\n1  void RegisterClass (WNDCLASS* WndClass);    register window class with this function\n   CreateWindow()\n1  HWND CreateWindow ( lpszClassName, lpszWindowName, dwStyle, x, y, nWidth, nHeight, hWndParent, hMenu. hInst, lpvParam );    create window with registered window class returns handle\n  lpszClassName : window class lpszWindowName : window\u0026rsquo;s name that will be shown on title bar dwStyle : the way how windows will be shown (?) x, y, nWidth, nHeight : location and size of window hWndParent : parent window\u0026rsquo;s handle (?) hMenu : control\u0026rsquo;s handle hInst : current application instance\u0026rsquo;s handle hpvParam : extra parameter (?)    1 2 3 4 5 6 7  #define WS_OVERLAPPEDWINDOW \\ (WS_OVERLAPPED |\\ WS_CAPTION |\\ WS_SYSMENU\t|\\ WS_THICKFRAME\t|\\ WS_MINIMIZEBOX\t|\\ WS_MAXIMIZEBOX)   WS_VISIBLE make you can skip ShowWindow() in some cases.\n  ShowWindow()\n1  void ShowWindow (hWnd, nCmdShow);    show created window instance on screen\n  hWnd nCmdShow  SW_HIDE : hide window (not minimize) SW_MINIMIZE : minimize window and not activate (inactive state) it SW_RESTORE : show window on screen (remember window posision and size when do min/max) SW_SHOW : show window on screen (?) SW_SHOWNORMAL : show window on screen (?)       GetMessage()\n1 2 3  BOOL GetMessage ( LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax ); //TranslateMessage( \u0026amp;Message );  //DispatchMessage( \u0026amp;Message );    get message from queue returns bool returns false when message is WM_QUIT to finish event loop\n  lpMsg : MSG structure\u0026rsquo;s pointer hWnd : message destination window\u0026rsquo;s handle. (search every message if hWnd is NULL) wMsgFilterMin, wMsgFilterMax : message range to search. (search every message if they are 0)      event example\n WM_QUIT : occur when user end program WM_LBUTTONDOWN : occur when mouse left button clicked WM_CHAR : occur when keyboard character inputed WM_PAINT : occur when screen need to be drawn again WM_DESTROY : occur when window deleted inside memory (normally occur WM_QUIT at the end to stop loop) WM_CREATE : occur when window is created (normally create child windows when this occur)    message struct\n1 2 3 4 5 6 7 8 9  typedef struct tagMSG { HWND\thwnd;\t//window handle  UINT\tmessage;\t//message  WPARAM\twParam;\t//window id  LPARAM\tlParam;\tDWORD\ttime;\t//time when event occur  POINT\tpt;\t//mouse position } MSG;     TranslateMessage()\n1  BOOL TranslateMessage ( CONST MSG* lpMsg );    translate event message into WM_CHAR type returns bool\n  lpMsg    DispatchMessage\n1  LONG DispatchMessage ( CONST MSG* lpMsg );    dispatch message to operating system to call window processor\n  lpMsg    PeekMessage()\n1  BOOL PeekMessage( LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg );    return TRUE if found message return FALSE if couldn\u0026rsquo;t find message\n  almost same with GetMessage, but different in read message disposal wRemoveMsg :  PM_REMOVE : remove message in queue PM_NOREMOVE : let message stay in queue      SendMessage()\n1  LResult SendMessage( HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam );    send message directly to message processor (not passing message queue)\n   PostMessage()\n1  LResult PostMessage( HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam );    post message on message queue\n      WndProc()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  LRESULT CALLBACK WndProc (HWND hWnd, UINT iMessage, WPARAM wParam, LPARAM lParam) { LPCTSTR text = L\u0026#34;window text example\u0026#34;; switch ( iMessage ) { case WM_PAINT: PAINTSTRUCT ps; HDC hdc = BeginPaint( hWnd, \u0026amp;ps );\t//hdc == handle device context  TextOut( hdc, 10, 10, text, lstrlen(text) ); EndPaint( hWnd, \u0026amp;ps ); return 0; // ... event cases ....  case WM_DESTROY: PostQuitMessage(0); return 0; } return DefWindowProc( hWnd, iMessage, wParam, lParam );\t// windows-default event processing  }    every window own window processor one by one WIndows will call with message to proper processor when event occurs main mission of Window processor is dealing with event, message and that makes callback function (window processor) do every job of window, even making child window\n  hWnd : window handle (return value of CreateWindow()) iMessage : event message wParam : used for WM_COMMAND lParam : used for WM_COMMAND     ","permalink":"https://niiok.github.io/windows/win32/","summary":"event driven\n when events happen, they stored into message form message stored into system queue OS was checking for system queue OS send message to aplication\u0026rsquo;s thread message queue application was checking for thread message queue (GetMessage) application calls event-matching callback function (TranslateMessage, DispatchMessage)    creating window\n declare WNDCLASS object declare proper LRESULT CALLBACK (*callback_function) (HWND, UINT, WPARAM, LPARAM) change fields(properties) inside WNDCLASS object  you need to set ipfnWndProc into callback_function as window processor you need to set lpszClassName into LPCSTR type string as window class name   declare WNDCLASS object with RegisterClass() Create window with CreateWindow()  you need to call ShowWindow() if window is invisible      window programming","title":"Win32"},{"content":"  controls are useful preset of child window\n but control is little different with normal child window  control doesn\u0026rsquo;t need class registing control send message(WM_COMMAND) to its parent window\u0026rsquo;s callback function (window processor)      send WM_COMMAND to parent window\n control gives parameters with wParam and lParam  wParam  4 bytes first 2 bytes contains Notify code, notifying what kind of message control made  can get with HIWORD(wParam)   last 2 bytes contains control\u0026rsquo;s ID  can get with LOWORD(wParam)     lParam  control\u0026rsquo;s handle        controls\n  button\n  editor\n  combo box\n  list box\n  text\n  spin\n  progress bar\n  MessageBox()\n1  int MessageBox( HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType );    make instant message box\n  hWnd : message box owner\u0026rsquo;s handle lpText : text inside message box lpCaption : tutle bar text uType : button type of message box  MB_OK MB_OKCANCEL MB_YESNO        ","permalink":"https://niiok.github.io/windows/control/","summary":"controls are useful preset of child window\n but control is little different with normal child window  control doesn\u0026rsquo;t need class registing control send message(WM_COMMAND) to its parent window\u0026rsquo;s callback function (window processor)      send WM_COMMAND to parent window\n control gives parameters with wParam and lParam  wParam  4 bytes first 2 bytes contains Notify code, notifying what kind of message control made  can get with HIWORD(wParam)   last 2 bytes contains control\u0026rsquo;s ID  can get with LOWORD(wParam)     lParam  control\u0026rsquo;s handle        controls","title":"Windows control"}]